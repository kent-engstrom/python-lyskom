#!/usr/bin/python
# Collect some [1] statistics about a conference
# $Id: komconfstats,v 1.7 2001/03/01 12:00:31 kent Exp $
# (C) 2000, 2001 Kent Engström. Released under GPL.
#
# SAKER ATT FIXA:
# - Mer statistik
#   - Mottagartyp: vanlig, extra kopia, bcc
#   - Antal mottagare
#   - Mera aux-items (t.ex. fast-replies)
# - Annat
#   - Förklarande text under rapporten
#   - Redovisa begränsningar (max_displayed) i lång titel
#   - Grafik via Gnuplot eller liknande
#   - Transponera (a,b) -> (b,a) istället för att samla flera samtidigt?
#
# The rest of the comments should be in English. Don't ask why,
# it just happens to be like that.
#
# --
# [1] or rather "more than you even knew you wanted"
#


import kom
import komparam
import sys
import getopt
import string
import re
import time
import math
import whrandom

import jddate # From the lyspython collection

# Get revision number from RCS/CVS
vc_revision = "$Revision: 1.7 $"
revision = vc_revision[11:-2]

# Error/sucess reporting
exit_code = 0
def error(str, code = 2, exit_now = 0):
    global exit_code
    exit_code = max(exit_code, code)
    sys.stderr.write("ERROR: " + str + "\n")
    if exit_now:
        exit()
        
def success(str):
    sys.stderr.write("OK: " + str + "\n")

def exit():
    sys.exit(exit_code)

#
# Split a text into words (removing the subject line!)
#

def split_text_into_words(text):
    first_nl = string.find(text,"\n")
    if first_nl <> -1:
        text = text[first_nl+1:]
    re_sanitize = re.compile("[^a-zåäö]+")

    def mymap(w, r = re_sanitize):
        return r.sub("", string.lower(w))

    def myfilter(w):
        return len(w)
    
    return filter(myfilter, map(mymap, string.split(text)))

# Handle counts and nouns
def get_count_with_noun(count, singularis, pluralis = None):
    if pluralis is None or count == 1:
        return "%d %s" % (count, singularis)
    else:
        return "%d %s" % (count, pluralis)


# Palindrome check
def is_palindrome(str):
    l1 = list(str)
    l2 = list(str)
    l2.reverse()
    return l1 == l2

#
# DATE PERIOD CLASS 
#
# This class is used to keep track of an open, closed or half-open
# date interval, and to figure out where a date is in relation to
# the interval.
#

class Period:
    def __init__(self):
        # Unlimited to start with
        self.begin = None
        self.end = None

    def __repr__(self):
        return "<Period %s ... %s>" % (self.begin, self.end)
    
    def set_today(self):
        self.begin = self.end = jddate.FromToday()

    def set_yesterday(self):
        self.begin = self.end = jddate.FromToday() -1

    def set_this_week(self):
        today = jddate.FromToday()
        self.begin = today.GetWeekStart()
        self.end = today.GetWeekEnd()

    def set_last_week(self):
        today = jddate.FromToday()
        self.begin = today.GetWeekStart() - 7
        self.end = today.GetWeekEnd() - 7 

    def set_this_month(self):
        today = jddate.FromToday()
        self.begin = today.GetMonthStart()
        self.end = today.GetMonthEnd()

    def set_last_month(self):
        today = jddate.FromToday()
        self.begin = (today.GetMonthStart()-1).GetMonthStart()
        self.end = self.begin.GetMonthEnd()

    def set_begin(self, str):
        self.begin = jddate.FromString(str)

    def set_end(self, str):
        self.end = jddate.FromString(str)

    def ymd_compare(self, y, m, d):
        # Return -1 if the date is before our beginning,
        #         0 if the date is within our limits (inclusively), or
        #        +1 if the date is after our end.
        date = jddate.FromYMD(y, m, d)
        if self.begin is not None and date < self.begin: return -1
        if self.end is not None and date > self.end: return +1
        return 0
    
    def ymd_is_inside(self, y, m, d):
        # Return true iff the date is within our boundaries (inclusively)
        return self.ymd_compare(y, m, d) == 0

    def format(self):
        if self.begin is None and self.end is None:
            return "obegränsad"
        elif self.begin is None:
            return "till och med " + self.end.GetString_YYYY_MM_DD()
        elif self.end is None:
            return "från och med " + self.begin.GetString_YYYY_MM_DD()
        else:
            return self.begin.GetString_YYYY_MM_DD() + " ... " +\
                   self.end.GetString_YYYY_MM_DD()
            
#
# Main classes for recording information, and their specializations.
#
# Tabulator is the most central class of them all. For a simple report
# such as "Articles per author", there is a single Tabulator (of
# subclass ConfNameTabulator) to handle the report. In its dictionary,
# each author gets an Entry that counts the texts written by him or her.
#
# For a two-dimensional report such as "Articles per subject line and
# author", the top-level Tabulator has a dictionary where each subject
# line gets a Tabulator (a ConfNameTabulator to be precise) of its
# own. Each such Tabulator has its own dictionary where the different
# authors using that subject lines get their Entries stored.
#
# The normal Tabulator class and its specializations produce reports
# sorted on the count (in descending order). The Histogram class and
# its specializations instead sort on the key, include lines where
# count is zero and show a bar of stars to visualize the count.
#
# New subclasses of Tabulator and Histogram should only be derived to
# handle large changes such as different key formats (or totally new
# forms of tabulation). Smaller customizations, such as titles,
# information on what kind of things that are counted, limits on the
# size of a report, etc., should be handled by the TabulatorProperties
# class. For each report, there is a chain of TabulatorProperties objects
# (just like a single-linked list in C or Pascal) with one object 
# for each level of the report.
#
# Now, read the code, and join me again when its time to review the
# Report class.

class Entry:
    def __init__(self, key, properties_ignored = None):
        self.key = key
        self.count = 0

    def tabulate(self, sub_keys):
        self.count = self.count + 1 

    def is_empty(self):
        return self.count == 0

    def report(self, indent, levels):
        # This is kind of faked, but it makes the code simpler...
        return []
       
class Tabulator(Entry):
    def __init__(self, key = None, properties = None):
        Entry.__init__(self, key)
        self.dict = {}  # Contains Entries/Tabulators
        if properties is None:
            self.prop = TabulatorProperties(self.__class__)
        else:
            self.prop = properties
            
    def tabulate(self, keys):
        self.count = self.count + 1
        if keys == []: return
        key = self.data_to_key(keys[0])
            
        if not self.dict.has_key(key):
            if self.prop.next is None:
                SubClass = Entry
            else:
                SubClass = self.prop.next.subclass
            self.dict[key] = SubClass(key, self.prop.next)
        self.dict[key].tabulate(keys[1:])

    def report(self, indent = 0, levels = None):
        # This methid is common for both normal tabulators and histograms

        # No report if we are past the max level
        if indent >= levels: return []
        
        l = [] # Collect lines of text using this one

        if indent == 0:
            # Only the top level should have a title
            l.append("%s (%s)" % (self.get_title(levels),
                                  self.prop.get_count_with_noun(self.count)))
            l.append("")
            self.report_extra_header(l)

        # Now, do the real work. Notice how "l" will be modified by
        # the addition of the report body lines.

        self.report_body(l, indent, levels)

        return l

    def get_title(self, levels = None):
        return self.prop.get_title(levels)

    def report_body(self, l, indent, levels):
        # Specific for tabulators, overridden by histograms
        
        istr = "      " * indent # Six spaces for each level of indentation
        sortlist = map(lambda x, d=self.dict: (-d[x].count, d[x]),
                       self.dict.keys())
        sortlist.sort()
        pos = 1
        last_occ = None 
        bailed_out = 0 # This will be set if we break because of max_displayed
        for (occ, entry) in sortlist:
            occ = - occ
            key = self.key_to_display(entry.key)

            if self.prop.max_displayed is not None and \
               pos > self.prop.max_displayed:
                bailed_out = 1
                break

            if occ <> last_occ:
                pos_str = str(pos)
            else:
                pos_str = '"'
            l.append("%s%3s) %s (%d)" % (istr, pos_str, key, occ))
            l.extend(entry.report(indent = indent + 1, levels = levels))
            pos = pos + 1
            last_occ = occ

        if bailed_out:
            l.append("%s     /%s/" % \
                     (istr,
                      get_count_with_noun(len(sortlist) -
                                          self.prop.max_displayed,
                                          "utelämnad rad","utelämnade rader")
                      ))
                               
        l.append("")
        
    # Override these methods if needed

    def report_extra_header(self, l):
        return

    def data_to_key(self, data):
        # This is how the data sent in will be transformed before
        # being used as a key.
        return data

    def key_to_display(self, key):
        # This is how the stored key will be transformed before
        # being displayed.
        return key


class ConfNameTabulator(Tabulator):
    # Stores conference numbers but displays them as names.

    def key_to_display(self, pers_no):
        return conn.conf_name(pers_no)

class CommentTabulator(Tabulator):
    # Stores pairs of conference numbers but displays them as names.
    
    def key_to_display(self, pers_tuple):
        return conn.conf_name(pers_tuple[0]) + " " + self.prop.separator + " " + \
               conn.conf_name(pers_tuple[1])

re_zero = re.compile(".*[1-9]([0-9]+)$")
class EvenNumberTabulator(Tabulator):
    # Stores the number of zero digits at the end of an article
    # number.
    
    def data_to_key(self, str):
        m = re_zero.match(str)
        return -len(m.group(1))

    def key_to_display(self, x):
        return "Jämna 1" + "0" * (-x) + "-tal"

class WordTabulator(Tabulator):
    def report_extra_header(self, l):
        r = whrandom.choice(self.dict.keys())
        l.append("Denna rapports slumpmässigt valda ord är:")
        l.append('    "%s", använt %s' % (r,
                                        get_count_with_noun(self.dict[r].count,
                                                            "gång","gånger")))
        l.append("")

class Histogram(Tabulator):
    def report_body(self, l, indent, levels):
        # Specific for histogram
        
        istr = "      " * indent # Six spaces for each level of indentation

        max_len = 50

        # Find minimum and maximum key, as well as maximum count
        # and maxmimum size of a cooked key

        min_key = None
        max_key = None
        max_occ = 0
        max_key_size = 0
        for (key,entry) in self.dict.items():
            occ = entry.count
            
            if min_key is None:
                min_key = key
            else:
                min_key = min(min_key, key)

            if max_key is None:
                max_key = key
            else:
                max_key = max(max_key, key)

            max_occ = max(max_occ, occ)
            max_key_size = max(max_key_size, len(self.key_to_display(key)))


        # The properties may override this, but only to extend it
        if self.prop.histogram_begin is not None and \
           self.prop.histogram_begin < min_key:
            min_key = self.prop.histogram_begin

        if self.prop.histogram_end is not None and \
           self.prop.histogram_end > max_key:
            max_key = self.prop.histogram_end

        # If we still have no limits, do not
        # generate anything more
        if min_key is None or max_key is None:
            return
        
        if max_occ == 0:
            divisor = 1
        else:
            divisor = (max_occ-1)/max_len+1

        # range(min_key, max_key+1) is not used, as this requires that the
        # type used as key has an __int__ method.
        raw_key = min_key
        while raw_key <= max_key:
            if self.dict.has_key(raw_key):
                entry = self.dict[raw_key]
                occ = entry.count
            else:
                entry = None
                occ = 0
            key = self.key_to_display(raw_key)
            bar_len = occ / divisor
            if divisor > 1:
                bar_len = bar_len + 1
            
            if occ == 0 and self.prop.histogram_hide_zero:
                l.append("%s     %-*s:" % (istr, max_key_size, key))
            else:
                l.append("%s     %-*s:%5d %s" % (istr, max_key_size, key, occ, "*" * bar_len))

            if entry is not None:
                l.extend(entry.report(indent = indent + 1, levels = levels))

            raw_key = raw_key + 1
            
        l.append("")

    def key_to_display(self, key):
        return str(key)

class HourHistogram(Histogram):
    def key_to_display(self, hour):
        return "%02d" % hour

swedish_weekdays = ["Måndag","Tisdag","Onsdag","Torsdag","Fredag","Lördag","Söndag"]
class WeekdayHistogram(Histogram):
    def key_to_display(self, wd):
        return swedish_weekdays[wd]
    
class DateHistogram(Histogram):
    def key_to_display(self, jd):
        (y, w, d) = jd.GetYWD()
        return jd.GetString_YYYY_MM_DD() + " " + \
               swedish_weekdays[d][:2]

class LogHistogram(Histogram):
    # Virtual --- use a subclass!
    def __init__(self, key = None, properties = None):
        self.logoflogbase = math.log(self.logbase)
        Histogram.__init__(self, key, properties) 
    
    def key_to_display(self, x):
        return "%6d -" % (self.logbase**x)

    def data_to_key(self, x):
        if x == 0: x = 1
        return int(math.log(x)/self.logoflogbase)

class SizeLogHistogram(LogHistogram):
    def __init__(self, key = None, properties = None):
        self.logbase = 2
        LogHistogram.__init__(self, key, properties) 

class BinHistogram(Histogram):
    # Virtual --- use a subclass!
    def __init__(self, key = None, properties = None):
        Histogram.__init__(self, key, properties)

    def key_to_display(self, x):
        return self.bins[x][1]

    def data_to_key(self, x):
        index = 0
        slot = index
        for (min, name) in self.bins:
            if x > min:
                slot = index
            index = index + 1
        return slot
    
class TimeBinHistogram(BinHistogram):
    def __init__(self, key = None, properties = None):
        self.bins = [(      0, " 0-15 s"),
                     (     15, "15-30 s"),
                     (     30, "30-45 s"),
                     (     45, "45-60 s"),
                     (     60, " 1- 5 m"),
                     (    300, " 5-10 m"),
                     (    600, "10-15 m"),
                     (    900, "15-30 m"),
                     (   1800, "30-45 m"),
                     (   3600, " 1- 2 h"),
                     (   7200, " 2- 4 h"),
                     (  14400, " 4- 6 h"),
                     (  21600, " 6-12 h"),
                     (  43200, "12-24 h"),
                     (  86400, " 1- 2 d"),
                     ( 172800, " 2- 4 d"),
                     ( 345600, " 4- 7 d"),
                     ( 604800, " 1- 2 w"),
                     (1209600, " 2- 4 w"),
                     (2419200, " 4-   w"),
                     ]
        BinHistogram.__init__(self, key, properties)

class TabulatorProperties:
    def __init__(self, subclass):
        self.next = None
        self.subclass = subclass
        self.title = "Rubrik saknas"
        self.what = "gazonk"
        self.singularis = "inlägg"
        self.pluralis = None
        self.max_displayed = None
        self.histogram_begin = None
        self.histogram_end = None
        self.histogram_hide_zero = 0
        
    def add_sub(self, subclass):
        if self.next is not None:
            raise ValueError, "add_sub called twice"
        self.next = TabulatorProperties(subclass)
        return self.next
    
    def set_histogram_range(self, begin = None, end = None):
        self.histogram_begin = begin
        self.histogram_end =   end
        
    def get_count_with_noun(self, count):
        return get_count_with_noun(count, self.singularis, self.pluralis)

    def get_title(self, levels):
        # We need to collect the "what" field from the chain of
        # TabulatorProperties:
        whatlist = []
        p = self
        while p is not None:
            whatlist.append(p.what)
            p = p.next
        if levels is not None:
            whatlist = whatlist[:levels]
            
        return self.title + ": " + string.join(whatlist, ", ")

#
# REPORT CLASS
#
# Thanks for tuning in to the comment channel again. I promised to
# explain the purpose of this class above. This class is
# able to encapsulate a Tabulator (or one of its subclasses)
# well enough to fool ConfStats.report(). Ask a real OO junkie
# if you really want to know the name of this pattern :-)
#
# The reason for inventing this class is to be able to use the same
# Tabulator to report more than once, with different levels of
# subtabulation. In that way, the same tabulator can produce
# both the "Articles per author" and "Articles per author, subject
# line" reports (but not the "Articles per subject line" or
# "Articles per subject line, author" reports).
#

class Report:
    def __init__(self, tabulator, levels = None):
        self.tabulator = tabulator
        self.levels = levels

    def is_empty(self):
        return self.tabulator.is_empty()
    
    def report(self):
        return self.tabulator.report(levels = self.levels)        

    def get_title(self):
        return self.tabulator.get_title(levels = self.levels)        
        
#
# CONFSTATS CLASS
#
# This is the real worker. An object of this class is used
# to read the articles of the conference, organize the data
# using all the nice little Tabulators and then produce all
# the reports (as text on stdout or as articles in a conference).
#

class ConfStats:
    def __init__(self, person, conference, period,
                 mark_earlier = 0, mark_processed = 0,
                 full_text = 0, post_to_conference = 0,
                 exclude_self = 0,
                 debug = 0):
        self.person = person
        self.conference = conference
        self.period = period
        self.mark_earlier = mark_earlier
        self.mark_processed = mark_processed
        self.full_text = full_text
        self.post_to_conference = post_to_conference
        self.exclude_self = exclude_self
        self.debug = debug

        self.reports = [] # The reports to produce, in order
        
    def add_report(self, tabulator):
        self.reports.append(tabulator)
        
    def gather(self):

        # First, declare tabulators. This is the part you should
        # change if you want to delete, move or add reports.

        self.at = ConfNameTabulator()
        self.at.prop.what = "författare"
        self.at.prop.title = "Inlägg"
        sub = self.at.prop.add_sub(Tabulator)
        sub.what = "ärenderad"
        sub.max_displayed = 10
        self.add_report(Report(self.at, 1))
        self.add_report(self.at)
        
        self.st = Tabulator()
        self.st.prop.title = "Inlägg"
        self.st.prop.what = "ärenderad"
        self.st.prop.max_displayed = 100
        sub = self.st.prop.add_sub(ConfNameTabulator)
        sub.what = "författare"
        sub.max_displayed = 10
        self.add_report(Report(self.st, 1))
        self.add_report(self.st)
     
        self.gat = ConfNameTabulator()
        self.gat.prop.what = "författare"
        self.gat.prop.title = "Inlägg av gästförfattare"
        sub = self.gat.prop.add_sub(Tabulator)
        sub.what = "ärenderad"
        self.add_report(self.gat)
      
        self.oat = ConfNameTabulator()
        self.oat.prop.what = "författare"
        self.oat.prop.title = "Originalinlägg"
        sub = self.oat.prop.add_sub(Tabulator)
        sub.what = "ärenderad"
        
        self.add_report(self.oat)
      
        self.sat = ConfNameTabulator()
        self.sat.prop.title = "Kommentarer med ändrad ärenderad"
        self.sat.prop.what = "författare"
        sub = self.sat.prop.add_sub(Tabulator)
        sub.what = "gammal ärenderad"
        sub = sub.add_sub(Tabulator)
        sub.what = "ny ärenderad"        
        self.add_report(self.sat)
      
        self.mat = ConfNameTabulator()
        self.mat.prop.title = "Kommentarer till texter i andra möten"
        self.mat.prop.what = "författare"
        sub = self.mat.prop.add_sub(ConfNameTabulator)
        sub.what = "möte"
        sub = sub.add_sub(Tabulator)
        sub.what = "ärenderad"
        # self.add_report(Report(self.mat, levels = 2))
        self.add_report(self.mat)
      
        self.rmat = ConfNameTabulator()
        self.rmat.prop.title = "Kommentarer till texter i andra möten"
        self.rmat.prop.what = "möte"
        sub = self.rmat.prop.add_sub(ConfNameTabulator)
        sub.what = "författare"
        sub = sub.add_sub(Tabulator)
        sub.what = "ärenderad"
        self.add_report(self.rmat)
      
        self.crt = ConfNameTabulator()
        self.crt.prop.title = "Inlägg i andra möten också"
        self.crt.prop.what = "möte"
        sub = self.crt.prop.add_sub(Tabulator)
        sub.what = "ärenderad"
        sub = sub.add_sub(ConfNameTabulator)
        sub.what = "författare"
        sub.max_displayed = 10
        self.add_report(self.crt)

        self.rcrt = Tabulator()
        self.rcrt.prop.title = "Inlägg i andra möten också"
        self.rcrt.prop.what = "ärenderad"
        sub = self.rcrt.prop.add_sub(ConfNameTabulator)
        sub.what = "möte"
        sub = sub.add_sub(ConfNameTabulator)
        sub.what = "författare"
        sub.max_displayed = 10
        self.add_report(self.rcrt)

        self.prt = ConfNameTabulator()
        self.prt.prop.title = "Inlägg mottagna av personer"
        self.prt.prop.what = "person"
        sub = self.prt.prop.add_sub(Tabulator)
        sub.what = "ärenderad"
        sub = sub.add_sub(ConfNameTabulator)
        sub.what = "författare"
        sub.max_displayed = 10
        self.add_report(self.prt)

        self.rprt = Tabulator()
        self.rprt.prop.title = "Inlägg mottagna av personer"
        self.rprt.prop.what = "ärenderad"
        sub = self.rprt.prop.add_sub(ConfNameTabulator)
        sub.what = "person"
        sub = sub.add_sub(ConfNameTabulator)
        sub.what = "författare"
        sub.max_displayed = 10
        self.add_report(self.rprt)

        self.fnat = ConfNameTabulator()
        self.fnat.prop.title = "Fotnoter"
        self.fnat.prop.what = "författare"
        self.add_report(self.fnat)
      
        self.scat = ConfNameTabulator()
        self.scat.prop.title = "Kommentarer till egna inlägg exkl. fotnoter"
        self.scat.prop.what = "författare"
        self.add_report(self.scat)
      
        self.cat0 = ConfNameTabulator()
        self.cat0.prop.title = "Inlägg utan kommentarer"
        self.cat0.prop.what = "författare"
        self.add_report(self.cat0)
      
        self.cat1 = ConfNameTabulator()
        self.cat1.prop.title = "Inlägg med minst 1 kommentar"
        self.cat1.prop.what = "författare"
        self.add_report(self.cat1)

        self.cat2 = ConfNameTabulator()
        self.cat2.prop.title = "Inlägg med minst 2 kommentarer"
        self.cat2.prop.what = "författare"
        self.add_report(self.cat2)

        self.cat3 = ConfNameTabulator()
        self.cat3.prop.title = "Inlägg med minst 3 kommentarer"
        self.cat3.prop.what = "författare"
        self.add_report(self.cat3)

        self.cat4 = ConfNameTabulator()
        self.cat4.prop.title = "Inlägg med minst 4 kommentarer"
        self.cat4.prop.what = "författare"
        self.add_report(self.cat4)

        self.cat5 = ConfNameTabulator()
        self.cat5.prop.title = "Inlägg med minst 5 kommentarer"
        self.cat5.prop.what = "författare"
        self.add_report(self.cat5)

        self.cat10 = ConfNameTabulator()
        self.cat10.prop.title = "Inlägg med minst 10 kommentarer"
        self.cat10.prop.what = "författare"
        self.add_report(self.cat10)

        self.ct = ConfNameTabulator()
        self.ct.prop.title = "Kommentarer"
        self.ct.prop.what = "författare"
        self.ct.prop.singularis = "kommentering"
        self.ct.prop.pluralis = "kommenteringar"
        sub = self.ct.prop.add_sub(ConfNameTabulator)
        sub.what = "kommenterad författare"
        sub.max_displayed = 10
        self.add_report(self.ct)
      
        self.rct = ConfNameTabulator()
        self.rct.prop.title = "Kommentarer"
        self.rct.prop.what = "kommenterad författare"
        self.rct.prop.singularis = "kommentering"
        self.rct.prop.pluralis = "kommenteringar"
        sub = self.rct.prop.add_sub(ConfNameTabulator)
        sub.what = "författare"
        sub.max_displayed = 10
        self.add_report(self.rct)
      
        self.dct = CommentTabulator()
        self.dct.prop.title = "Kommentarer"
        self.dct.prop.what = "personpar (varje riktning för sig)"
        self.dct.prop.separator = "kommenterar"
        self.dct.prop.singularis = "kommentering"
        self.dct.prop.pluralis = "kommenteringar"
        self.dct.prop.max_displayed = 50
        self.add_report(self.dct)
      
        self.nct = CommentTabulator()
        self.nct.prop.title = "Kommentarer"
        self.nct.prop.what = "personpar (oavsett riktning)"
        self.nct.prop.separator = "och"
        self.nct.prop.singularis = "kommentering"
        self.nct.prop.pluralis = "kommenteringar"
        self.nct.prop.max_displayed = 50
        self.add_report(self.nct)

        self.vt = Tabulator()
        self.vt.prop.title = "Inlägg"
        self.vt.prop.what = "klient"
        sub = self.vt.prop.add_sub(Tabulator)
        sub.what = "version"
        self.add_report(self.vt)
     
        self.ctt = Tabulator()
        self.ctt.prop.title = "Inlägg"
        self.ctt.prop.what = "content-type"
        sub = self.ctt.prop.add_sub(Tabulator)
        sub.what = "options"
        self.add_report(self.ctt)
     
        self.ent = EvenNumberTabulator()
        self.ent.prop.title = "Jubelinlägg"
        self.ent.prop.what = "jubeltyp"
        sub = self.ent.prop.add_sub(ConfNameTabulator)
        sub.what = "författare"
        sub = sub.add_sub(Tabulator)
        sub.what = "inläggsnummer"
        self.add_report(self.ent)

        self.pal = ConfNameTabulator()
        self.pal.prop.title = "Palindromnummerinlägg"
        self.pal.prop.what = "författare"
        sub = self.pal.prop.add_sub(Tabulator)
        sub.what = "inläggsnummer"
        self.add_report(self.pal)
     
        if self.full_text:
            self.wt = WordTabulator()
            self.wt.prop.title = "Ord i texter"
            self.wt.prop.what = "ord"
            self.wt.prop.singularis = "ord"
            self.wt.prop.max_displayed = 200
            self.add_report(self.wt)

        # Histograms
        
        self.hh = HourHistogram()
        self.hh.prop.title = "Inlägg"
        self.hh.prop.what = "timme på dygnet"
        self.hh.prop.set_histogram_range(0, 23)
        self.hh.prop.histogram_hide_zero = 1
        sub = self.hh.prop.add_sub(ConfNameTabulator)
        sub.what = "författare"
        sub.max_displayed = 5
        self.add_report(Report(self.hh, 1))
        self.add_report(self.hh)
            
        self.wh = WeekdayHistogram()
        self.wh.prop.title = "Inlägg"
        self.wh.prop.what = "veckodag"
        self.wh.prop.set_histogram_range(0,6)
        self.wh.prop.histogram_hide_zero = 1
        sub = self.wh.prop.add_sub(ConfNameTabulator)
        sub.what = "författare"
        sub.max_displayed = 5
        self.add_report(Report(self.wh, 1))
        self.add_report(self.wh)
            
        self.dh = DateHistogram()
        self.dh.prop.title = "Inlägg"
        self.dh.prop.what = "datum"
        self.dh.prop.histogram_hide_zero = 1
        sub = self.dh.prop.add_sub(ConfNameTabulator)
        sub.what = "författare"
        sub.max_displayed = 5
        self.add_report(Report(self.dh, 1))
        self.add_report(self.dh)
            
        self.dst = Tabulator()
        self.dst.prop.title = "Inlägg"
        self.dst.prop.what = "ärenderad"
        self.dst.prop.max_displayed = 20
        sub = self.dst.prop.add_sub(DateHistogram)
        sub.what = "datum"
        self.add_report(self.dst)
     
        self.kh = Histogram()
        self.kh.prop.title = "Inlägg"
        self.kh.prop.what = "antal kommentarer"
        self.kh.prop.histogram_hide_zero = 1
        self.add_report(self.kh)
            
        self.csh = SizeLogHistogram()
        self.csh.prop.title = "Inlägg"
        self.csh.prop.what = "antal tecken"
        self.csh.prop.histogram_hide_zero = 1
        self.add_report(self.csh)
            
        self.lsh = SizeLogHistogram()
        self.lsh.prop.title = "Inlägg"
        self.lsh.prop.what = "antal rader"
        self.lsh.prop.histogram_hide_zero = 1
        sub = self.lsh.prop.add_sub(ConfNameTabulator)
        sub.what = "författare"
        sub.max_displayed = 5
        self.add_report(Report(self.lsh, 1))
        self.add_report(self.lsh)
            
        self.ah = TimeBinHistogram()
        self.ah.prop.title = "Kommentarer"
        self.ah.prop.what = "antal sekunder sedan det kommenterade"
        self.ah.prop.histogram_hide_zero = 1
        sub = self.ah.prop.add_sub(ConfNameTabulator)
        sub.what = "författare"
        sub.max_displayed = 5
        self.add_report(Report(self.ah, 1))
        self.add_report(self.ah)

        # Stop! The declaration of tabulators end here. Below
        # lies Real Code <tm>.
            
        # Learn the members of the conference
        # FIXME: What maximum number should be used?
        members = map(lambda x: x.member,
                      kom.ReqGetMembers(conn,
                                        self.conference,
                                        0, 16384).response())
        
        # Traverse the texts.
        unread_texts = conn.get_unread_texts(self.person, conference)
        if self.debug:
            sys.stderr.write("Number of unread texts: %d\n" %len(unread_texts))
        for (loc_no, global_no) in unread_texts:

            # Skip erased texts.
            # FIXME: Some day, somebody should figure out if entries
            # with global_no == 0 should really be present in the
            # list given to us by kom.py.
            if global_no == 0:
                continue
            ts = conn.textstats[global_no]

            # Check creation time of article
            created = ts.creation_time.to_python_time()
            cmp = period.ymd_compare(ts.creation_time.year + 1900,
                                     ts.creation_time.month + 1,
                                     ts.creation_time.day)
            if cmp < 0:
                # Earlier than the requested period
                if self.debug:
                    sys.stderr.write("- %d %s\n" %( global_no, time.ctime(created)))
                if self.mark_earlier:
                    kom.ReqMarkAsRead(conn,
                                      self.conference,
                                          [loc_no]).response()
                    
                continue
            elif cmp > 0:
                # Later then the requested period
                if self.debug:
                    sys.stderr.write("+ %d %s\n" %( global_no, time.ctime(created)))
                continue
            else:
                # Inside the requested period, fall through to do the work
                if self.debug:
                    sys.stderr.write("* %d %s\n" %( global_no, time.ctime(created)))
                pass

            # Skip texts by myself
            if exclude_self and ts.author == self.person:
                # FIXME: Figure out when to mark as read
                continue

            # Tabulate simple things that only depend on this text
            subject = conn.subjects[global_no]
            self.at.tabulate([ts.author, subject])
            self.st.tabulate([subject, ts.author])
            if ts.author not in members:
                self.gat.tabulate([ts.author, subject])
            self.hh.tabulate([ts.creation_time.hours, ts.author])
            self.wh.tabulate([(ts.creation_time.day_of_week-1)%7, ts.author])
            self.dh.tabulate([jddate.FromUnixTime(ts.creation_time.to_python_time()), ts.author])
            self.dst.tabulate([subject, jddate.FromUnixTime(ts.creation_time.to_python_time())])
            self.csh.tabulate([ts.no_of_chars])
            self.lsh.tabulate([ts.no_of_lines, ts.author])

            # Even numbers ("jubel")
            # FIXME: This is base 10. Should we do base-2 also?
            
            numstr = str(global_no)
            if numstr[-3:] == "000":
                self.ent.tabulate([numstr, ts.author, numstr])

            # Palindromes
            if is_palindrome(numstr):
                self.pal.tabulate([ts.author, numstr])

            # Tabulate things that depend on the recipient list
            for mir in ts.misc_info.recipient_list:
                if mir.recpt <> self.conference:
                    if conn.uconferences[mir.recpt].type.letterbox:
                        self.prt.tabulate([mir.recpt, subject, ts.author])
                        self.rprt.tabulate([subject, mir.recpt, ts.author])

                    else:
                        self.crt.tabulate([mir.recpt, subject, ts.author])
                        self.rcrt.tabulate([subject, mir.recpt, ts.author])

            # Tabulate things that depend on the aux-items
            # CREATING SOFTWARE
            ai_c_s = kom.first_aux_items_with_tag(ts.aux_items,
                                                  kom.AI_CREATING_SOFTWARE)
            if ai_c_s is not None:
                (c_s,c_s_version) = (string.split(ai_c_s.data)+[""])[:2]
                self.vt.tabulate([c_s, c_s_version])
            else:
                self.vt.tabulate(["Ej specificerad", "Ingen version"])

            # CONTENT_TYPE
            ai_c_t = kom.first_aux_items_with_tag(ts.aux_items,
                                                  kom.AI_CONTENT_TYPE)
            if ai_c_t is not None:
                (c_t,c_t_options) = (string.split(ai_c_t.data,";")+[""])[:2]
                self.ctt.tabulate([c_t, c_t_options])
            else:
                self.ctt.tabulate(["Ej specificerad","Inga optioner"])
                
            # Tabulate things that depend on the commented text(s)

            # NOTICE: Things tallied inside the for loop could get
            # rather confused (e.g. an article counted multiple times)
            # when an article is a comment to more than one other article.
            # However, this may be a small price to pay to get some more
            # interesting information for all "normal" chains.
            
            if len(ts.misc_info.comment_to_list) == 0:
                self.oat.tabulate([ts.author, subject])
            else:
                recipients_of_commented_includes_this_conference = 0
                this_is_a_footnote = 0
                this_is_a_self_comment= 0
                for entry in ts.misc_info.comment_to_list:
                    try:
                        ts_commented = conn.textstats[entry.text_no]
                    except kom.NoSuchText:
                        continue
                    
                    # Subject change?
                    old_subject = conn.subjects[entry.text_no]
                    if old_subject <> subject:
                        self.sat.tabulate([ts.author, old_subject, subject])

                    # Who comments whom? First both directions separately...
                    a1 = ts.author
                    a2 = ts_commented.author
                    self.ct.tabulate([a1,a2])
                    self.rct.tabulate([a2,a1])
                    self.dct.tabulate([(a1,a2)])
                    # ... then mixed together
                    if a1 > a2:
                        (a1, a2) = (a2, a1)
                    self.nct.tabulate([(a1,a2)])

                    # Find out if the commented text is also in
                    # our conference
                    recpts_of_commented = map(lambda x: x.recpt,
                                              ts_commented.misc_info.recipient_list)
                    if not self.conference in recpts_of_commented:
                        # FIXME: Here, we will count each article once
                        # for every conference the parent was in...
                        for c in recpts_of_commented:
                            self.mat.tabulate([ts.author, c, subject])
                            self.rmat.tabulate([c, ts.author, subject])

                    # Footnote?
                    if entry.type == kom.MIC_FOOTNOTE:
                        this_is_a_footnote = 1

                    # Self-comment?
                    if entry.type == kom.MIC_COMMENT and \
                       ts_commented.author == ts.author:
                        this_is_a_self_comment = 1

                    # Time between parent and comment
                    created_commented = ts_commented.creation_time.to_python_time()
                    age = int(created - created_commented)
                    if age >= 0:
                        self.ah.tabulate([age, ts.author])

                # Now, tally the things we do not want/need to
                # tally inside the loop
                if this_is_a_footnote:
                    self.fnat.tabulate([ts.author])

                if this_is_a_self_comment:
                    self.scat.tabulate([ts.author])
                    
            # Tabulate things that depend on the comment(s)
            no_c = len(ts.misc_info.comment_in_list)
            self.kh.tabulate([no_c])
            if no_c == 0:
                self.cat0.tabulate([ts.author])
            else:
                if no_c >= 1:
                    self.cat1.tabulate([ts.author])
                    if no_c >= 2:
                        self.cat2.tabulate([ts.author])
                        if no_c >= 3:
                            self.cat3.tabulate([ts.author])
                            if no_c >= 4:
                                self.cat4.tabulate([ts.author])
                                if no_c >= 5:
                                    self.cat5.tabulate([ts.author])
                                    if no_c >= 10:
                                        self.cat10.tabulate([ts.author])

            # Get the text and tabulate the words (max size=1024*1024)

            if self.full_text:
                text = kom.ReqGetText(conn, global_no, 0, 1024*1024).response()
                for word in split_text_into_words(text):
                    self.wt.tabulate([word])
          

            # Mark the text as read if requested
            if self.mark_processed:
                kom.ReqMarkAsRead(conn, self.conference, [loc_no]).response()
            
    def report(self):
        title = "Statistik för " + conn.conf_name(self.conference)

        lines = ["Statistik för " + conn.conf_name(self.conference),
                 "Perioden är " + self.period.format()]

        if self.exclude_self:
            lines.append("Inlägg av %s är inte medräknade" % conn.conf_name(self.person))
            
        lines.extend([ "", 
                       "Följande rapporter följer som kommentarer till detta inlägg:",
                 ""])
        
        empty_lines = []
        
        for r in self.reports:
            if r.is_empty():
                empty_lines.append("- " + r.get_title()) 
            else:
                lines.append("- " + r.get_title()) 

        if len(empty_lines) > 0:
            lines.append("")
            lines.append("Följande rapporter är tomma och kommer inte att visas:")
            lines.append("")
            lines.extend(empty_lines)
            
        body = string.strip(string.join(lines, "\n"))
        no = self.write_article(title, body)
            
        for r in self.reports:
            if r.is_empty(): continue
            
            title = r.get_title()
            lines = ["Statistik för " + conn.conf_name(self.conference),
                     ""] + r.report()
            body = string.strip(string.join(lines, "\n"))
            self.write_article(title, body, comment_to = no)

    def write_article(self, title, body, comment_to = None):
        if self.post_to_conference:
            misc_info = kom.CookedMiscInfo()

            mir = kom.MIRecipient(kom.MIR_TO, self.conference)
            misc_info.recipient_list.append(mir)
            
            if comment_to is not None:
                mic = kom.MICommentTo(kom.MIC_COMMENT, comment_to)
                misc_info.comment_to_list.append(mic)

            aux_items = []
            ai = kom.AuxItem(kom.AI_CREATING_SOFTWARE)
            ai.data = "komconfstat %s" % revision
            aux_items.append(ai)

            text = title + "\n" + body
            text_no = kom.ReqCreateText(conn, text,
                                        misc_info, aux_items).response()
            return text_no
        
        else:
            print title
            print "=" * len(title)
            print
            print body
            print

# MAIN
# Connect and log in
# Notice: conn is a global variable used in a lot of places

param = komparam.Parameters(sys.argv[1:])
(conn, conn_error) = param.connect_and_login(kom.CachedConnection)
if conn is None:
    sys.stderr.write("%s: %s\n" % (sys.argv[0], conn_error))
    sys.exit(1)
conn.enable_req_histo()

#
# CHECK FOR OPTIONS
#

conference = None
period = Period()
mark_earlier = 0
mark_processed = 0
full_text = 0
post_to_conference = 0
exclude_self = 0
debug = 0

options, arguments = getopt.getopt(param.get_arguments(),
                                   "",
                                   ["conference=",
                                    "today",
                                    "yesterday",
                                    "this-week",
                                    "last-week",
                                    "this-month",
                                    "last-month",
                                    "begin=",
                                    "end=",
                                    "mark-earlier", 
                                    "mark-processed",
                                    "full-text",
                                    "post-to-conference",
                                    "exclude-self",
                                    "debug",
                                    ])

for (opt, optarg) in options:
    if opt == "--conference":
        matches = conn.lookup_name(optarg, 1, 1)
        if len(matches) == 0:
            error("%s -- conference not found" % optarg)
        elif len(matches) <> 1:
            error("%s -- ambiguous recipient" % optarg)
        else:
            conference = matches[0][0]
    elif opt == "--today":
        period.set_today()
    elif opt == "--yesterday":
        period.set_yesterday()
    elif opt == "--this-week":
        period.set_this_week()
    elif opt == "--last-week":
        period.set_last_week()
    elif opt == "--this-month":
        period.set_this_month()
    elif opt == "--last-month":
        period.set_last_month()
    elif opt == "--begin":
        period.set_begin(optarg)
    elif opt == "--end":
        period.set_end(optarg)
    elif opt == "--mark-earlier":
        mark_earlier = 1
    elif opt == "--mark-processed":
        mark_processed = 1
    elif opt == "--full-text":
        full_text = 1
    elif opt == "--post-to-conference":
        post_to_conference = 1
    elif opt == "--exclude-self":
        exclude_self = 1
    elif opt == "--debug":
        debug = 1

    else:
        error("Option %s not handled (internal error)" % opt, exit_now = 1)

if conference is None:
    error("No conference given!", exit_now = 1)
    
cstats = ConfStats(param.get_person_no(), conference, period,
                   mark_earlier = mark_earlier,
                   mark_processed = mark_processed,
                   full_text = full_text,
                   post_to_conference = post_to_conference,
                   exclude_self = exclude_self,
                   debug = debug)

cstats.gather()
cstats.report()

# People that are curiosity-challenged will comment out the following
# two lines:
conn.report_cache_usage()
conn.show_req_histo()

# Exit successfully
exit()

