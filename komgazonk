#!/usr/bin/env python

# LysKOM gazonk client

# (C) 2002 Ragnar Ouchterlony. Released under GPL.

import kom
import time
import select
import string
import sys
import os
import os.path
import re
from komgazonk_config import *
import cPickle
import random
import copy

CLIENTNAME="komgazonk"
VERSION="0.2.1"

INVISIBLE = 1

MAX_ENTRIES_GUESS_LIST = 300

wrong_guess_list = ["Fel, fel, fel, fel!", \
                    "Nepp!", \
                    "Nähä!", \
                    "Inte alls.", \
                    "Helt fel.", \
                    "Trodde du verkligen att det skulle vara rätt?", \
                    "Om du läser ledtrådarna först går det nog bättre.", \
                    "En daggmask hade kommit på något bättre än det där.", \
                    "Till och med du borde kunna komma på något bättre.", \
                    "Det var ju riktigt nära! Nej, jag bara skojade.", \
                    "Jag hoppas för din skull att det där var en feltryckning.", \
                    "*Gäsp* Säg till när du skall göra en seriös gissning.", \
                    "Du är inte ens nära.", \
                    "Mwhahahahahahahah.", \
                    "Flicka lilla, du kanske borde fråga din mamma?", \
                    "Fet chans, grabbhalva!", \
                    "Där högg du allt i sten.", \
                    "Whoah, ingen dålig gissning!", \
                    "Mmmm, nästan. Försök igen.", \
                    "Du ska gissa med svenska ord, hörrö!", \
                    "Var det där en gissning, eller?", \
                    "Du vet ju inte ens HUR man gissar!", \
                    "Gissa på du, än är det långt kvar.", \
                    "Ta du och vänta på nästa ledtråd.", \
                    "Kom igen om ett par dar, då är en ny gazonk på G.", \
                    "Det där lösenordet var ju gazonk förra veckan.", \
                    "Hörde du det där ordet på radion nyss, eller?", \
                    "I vilken ordbok hittade du den gissningen då?", \
                    "Du fuskar, du har Gooooooglat!!! Men det var ändå fel.", \
                    "Loser!", \
                    "En nyfödd gissar bättre än du.", \
                    "Du är ful, och fel gissar du också!", \
                    "Trodde du ja!", \
                    "Hur många tror du inte har gissat på det före dej då?", \
                    "Ta o lägg ner, va?", \
                    "Så puttinuttigt då... MEN DET ÄR FEEEEL!", \
                    "Hur tänker du då?", \
                    "Du skulle nog svängt vänster där borta... Du är ju helt vilse!", \
                    "Pfft, knappast.", \
                    "Men du är ju hopplös!", \
                    "Skärp dig!", \
                    "Du kanske skulle fråga skräphögen om råd.", \
                    "Det är aldrig försent att ge upp."]

help_string = """Möjliga kommandon:
------------------
'hjälp':              Skicka detta hjälpmeddelande.
'hjälp statistik':    Skicka ett hjälpmeddelande om statistiken.
'vem':                Talar om vem som är gazonk.
'visa':               Listar givna ledtrådar.
'nästa':              Talar om hur långt det är kvar till nästa ledtråd.
'gamla lösenord':     Visar en lista på de 50 senaste lösenorden.
'statistik':          Visar lite staitistik om ditt gazonkande.
'statistik <person>': Visar statistik om given person.

Om du är gazonk:
----------------
'lösenord':                     Visar lösenord om omgången är startad.
'lösenord <nytt lösenord>':     Byter lösenord då omgång ej är startad.
'ledtråd':                      Visar alla ledtrådar.
'ledtråd <en ledtråd>':         Lägger in en ny ledtråd.
'byt ledtråd <nr> <en ledtråd>: Byter ut en ledtråd mot en annan.
'gissningar':                   Visar alla gissningar för nuvarande
                                gazonkning.
'gissningar <ledtrådsnr>        Visar alla gissningar för på den
                                ledtråden.
Om du inte är gazonk:
---------------------
'gissa <gissning>:              Gissa på lösenordet.
'<gissning>:                    Samma som ovan.
'ny gazonk':                    Bli gazonk, om ingen är gazonk redan."""

help_stats_string = """Gissn  = antal gissningar
Korr   = antal korrekta gissningar
k/g    = andel korrekta gissningar (procent)
Led    = antal ledtrådar som behövts i snitt för att klara lösenordet
GLed   = antal ledtrådar motståndarna behövt i snitt för att klara
         lösenordet när personen är gazonk
g/k    = antal gissningar i snitt för att klara ett lösenord
Gg/k   = antal gissningar i snitt motståndarna behöver för att klara
         lösenordet när personen är gazonk
g/l    = antal gissningar i snitt per given ledtråd för att
         klara ett lösenord
Gg/l   = antal gissningar i snitt per given ledtråd motståndarna
         behöver för att klara lösenordet när personen är gazonk
Person = för denna person"""


class Gazonk:
    re_auto_reply = re.compile("^Auto-reply:", re.IGNORECASE)
    re_ny_gazonk = re.compile("^ny gazonk$", re.IGNORECASE)
    re_losenord_a = re.compile("^lösenord", re.IGNORECASE)
    re_losenord_b = re.compile("^[Ll][Öö][Ss][Ee][Nn][Oo][Rr][Dd] *([" + GAZ_PW_CHARS + \
                               "]{1," + str(GAZ_PW_LENGTH) + "}) *$")
    re_gissning = re.compile("^[" + GAZ_PW_CHARS + "]{1," + str(GAZ_PW_LENGTH) + "}$")
    re_ledtrad = re.compile("^ledtråd( *| +(.+))$", re.IGNORECASE)
    re_byt_ledtrad = re.compile("^byt ledtråd +([0-9]+) +(.+)$", re.IGNORECASE)
    re_gissningar = re.compile("^gissningar *([0-9]*) *$")
    re_gissa = re.compile("^gissa *(.*) *$")
    re_vem = re.compile("^vem$", re.IGNORECASE)
    re_visa = re.compile("^visa$", re.IGNORECASE)
    re_nasta = re.compile("^nästa$", re.IGNORECASE)
    re_hjalp = re.compile("^hjälp$", re.IGNORECASE)
    re_hjalp_statistik = re.compile("^hjälp statistik$", re.IGNORECASE)
    re_gamla_losenord = re.compile("^gamla lösenord$", re.IGNORECASE)
    re_statistik = re.compile("^statistik *(.*) *$", re.IGNORECASE)

    def __init__(self):
        self.startup_time = time.time()
        self.current_time = time.time()
        self.password_history = []
        self.tstats = TotStats()
        self.current_guesses = GuessDB()
        self.reset()

    def reset(self):
        self.person_no = -1
        self.password = "";
        self.clues = []
        self.current_clue = -1
        self.time_last_action = -1
        self.warnings_sent = 0
        self.last_text_no = -1
        self.current_guesses.reset()
        self.per_clue_guesses = []

    def set_last_action(self):
        self.time_last_action = time.time()

    def set_current_time(self):
        self.current_time = time.time()

    def create_guess_list_string(self, max_nr = MAX_ENTRIES_GUESS_LIST):
        message = ""
        i = 0
        for gdb in self.per_clue_guesses:
            i += 1
            message += "Gissningar för ledtråd %d:\n" % i
            message += "----------------------------\n"
            message += print_clue(self.clues[i-1], i)
            message += "\n----------------------------\n"
            message += gdb.create_string(MAX_ENTRIES_GUESS_LIST)
            message += "\n"

        message += "Alla gissningar:\n"
        message += "----------------------------\n"
        message += self.current_guesses.create_string(MAX_ENTRIES_GUESS_LIST, "Totalt")
        return message

    def create_clue_string(self, disp_all):
        clues = self.clues
        if disp_all == 0:
            if self.current_clue == -1:
                return "Inga ledtrådar att visa\n"
            clues = clues[:(self.current_clue+1)]
        elif disp_all == 2:
            if self.current_clue == -1:
                return "Inga ledtrådar att visa\n"
            clues = clues[(self.current_clue+1):]

        if len(clues) == 0:
            return "Inga ledtrådar att visa\n"

        clue_string = ""
        i = 0
        if disp_all == 2:
            i = self.current_clue+1
        for c in clues:
            i += 1
            clue_string += print_clue(c, i) + "\n"
        return clue_string

    def send_end_of_round_message(self, subject, message):
        self.tstats.end_round()
        message += "\n\nLösenordet var '%s'.\n\n" % self.password
        message += "Givna ledtrådar:\n"
        message += self.create_clue_string(0)
        message += "\nIcke givna ledtrådar:\n"
        message += self.create_clue_string(2) + "\n"
        message += self.create_guess_list_string(MAX_ENTRIES_GUESS_LIST)
        self.send_letter(subject, message, GAZONK_CONF, 0, 0)

    def send_next_clue_letter(self, dont_increase = 0):
        new = 0
        if dont_increase == 0:
            self.current_clue += 1
            self.tstats.new_given_clue()
            self.per_clue_guesses.append( GuessDB() )
            if self.current_clue == 0:
                new = 1

        gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
        mess_subject = "%s gazonkar" % shorten_name(gaz_name)
        mess_text = self.create_clue_string(0)
        self.send_letter(mess_subject, mess_text, GAZONK_CONF, new, 0)

    def send_clue_message(self, recipient, disp_all):
        send_string = "Ledtrådar:\n\n"
        send_string += self.create_clue_string(disp_all)

        send_message(send_string, recipient)

    def send_letter(self, subject, message, recipient, new, person):
        recipient_name = kom.ReqGetUconfStat(conn, recipient).response().name
        log("%s: Brev till %s:" % (get_date_and_time(), recipient_name))
        log(indent(message, 2) + "\n")

        misc_info = kom.CookedMiscInfo()
        rec = kom.MIRecipient(kom.MIR_TO, recipient)
        misc_info.recipient_list.append(rec)

        if new == 0 and person == 0 and self.last_text_no > 0:
            try:
                ts = conn.textstats[self.last_text_no]
                mic = kom.MICommentTo(kom.MIC_COMMENT, self.last_text_no)
                misc_info.comment_to_list.append(mic)
            except:
                log("Old text number %d not found" % self.last_text_no)

        send_text = subject + "\n" + message
        text_no = kom.ReqCreateText(conn, send_text, misc_info, []).response()
        if person == 0:
            self.last_text_no = text_no

    def check_monthly(self):
        self.tstats.check(self)

    def check_clues(self):
        log("Checking if we should send out clues or warnings.")

        # Skall vi börja en ny omgång?
        if len(self.password) > 0 and \
           len(self.clues) > 0 and \
           self.current_clue == -1:
            self.send_next_clue_letter()
            self.set_last_action()
            self.warnings_sent = 0
            self.tstats.new_round()
            return

        current_time = time.time()
        # Skall vi skicka ut en ny ledtråd?
        if self.current_clue > -1 and \
           len(self.clues) > self.current_clue + 1 and \
           current_time - self.time_last_action > GAZONK_CLUE_TIME:
            self.send_next_clue_letter()
            self.set_last_action()
            self.warnings_sent = 0
            return

        # Dags att skicka ut påminnelse tro?
        if self.person_no > 0 and \
           ((len(self.password) == 0 and len(self.clues) == 0) or \
            len(self.clues) <= self.current_clue + 1) and \
           current_time - self.time_last_action > \
           GAZONK_REMEMBER_TIME * (self.warnings_sent + 1):
            self.warnings_sent += 1

            # Har vi skickat tillräckligt med varningar nu?
            if self.warnings_sent > GAZ_MAX_WARNINGS:
                my_name = kom.ReqGetUconfStat(conn, KOMPERSON).response().name
                gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
                self.send_letter("Du är inte längre gazonk!",
                                 "Du har inte lyssnat på varningarna och blir därmed \n" + \
                                 "fråntagen din gazonktitel!",
                                 self.person_no, 1, 1)
                subject = "%s ej längre gazonk!" % shorten_name(gaz_name)
                message = "Vem som helst kan nu bli gazonk. Skicka bara 'ny gazonk'" + \
                          "\ni ett meddelande till <Person %d: %s>" % (KOMPERSON, my_name)
                if len(self.password) > 0 and len(self.clues) > 0:
                    self.send_end_of_round_message(subject, message)
                else:
                    self.send_letter(subject, message, GAZONK_CONF, 0, 0)
                self.reset()
                return

            # Skicka varningen
            message = "\n\nNu har det gått %d minuter sedan du blev gazonk.\n" % \
                       ((current_time - self.time_last_action)/60)
            message += "Det finns inte tillräckligt med ledtrådar i ledtrådskön.\n\n"
            message += "Det här är varning %d av max %d, sedan kommer din \n" % \
                       (self.warnings_sent, GAZ_MAX_WARNINGS)
            message += "gazonk-titel att fråntas dig!"
            self.send_letter("Detta är en påminnelse om att du är gazonk!",
                             message, self.person_no, 1, 1)
            return

    def parse_message(self, msg, c):
        #Om det inte är till gazonk personligen, skall vi inte svara.
        if msg.recipient != KOMPERSON:
            return

        sender_name = kom.ReqGetUconfStat(conn, msg.sender).response().name
        log("%s: Meddelande (%d) från %s:" % (get_date_and_time(), msg.recipient, sender_name))
        log(indent(msg.message, 2) + "\n")

        # Svara ej på automatsvar.
        m = Gazonk.re_auto_reply.search(msg.message)
        if m:
            return

        # Behöver man hjälp?
        m = Gazonk.re_hjalp.search(msg.message)
        if m:
            send_message(help_string, msg.sender)
            return

        # Behöver man hjälp med statistiken?
        m = Gazonk.re_hjalp_statistik.search(msg.message)
        if m:
            send_message(help_stats_string, msg.sender)
            return

        # Saker som endast kan göras om ingen gazonk finns:
        if self.person_no == -1:
            # Är detta en request för ny gazonk?
            m = Gazonk.re_ny_gazonk.search(msg.message)
            if m:
                self.reset()
                self.person_no = msg.sender
                self.set_last_action()
                send_message("Du är nu ny gazonk!", msg.sender)
                return

        # Saker som endast nuvarande gazonk får göra:
        if self.person_no == msg.sender:
            # Skall vi sätta ett nytt lösenord
            ma = Gazonk.re_losenord_a.search(msg.message)
            mb = Gazonk.re_losenord_b.match(msg.message)
            # Vi får enbart sätta lösenordet om omgången ej är startad än.
            # Skicka tillbaka lösenordet istället.
            if ma and self.current_clue > -1:
                send_message("Har du blivit senil? Nuvarande lösenord är '%s'." % \
                             self.password, \
                             msg.sender)
                return
            elif ma and mb:
                self.password = mb.group(1)
                self.clues = []
                self.current_clue = -1
                self.time_last_action = -1
                self.warnings_sent = 0
                self.last_text_no = 0
                self.set_last_action()
                send_message("Nytt lösenord är '%s'." % self.password, msg.sender)
                return
            elif ma:
                send_message("Ditt lösenord godkändes ej.\n\n" + \
                             "Ett lösenord skall enbart innehålla bokstäverna\n" + \
                             "a-z, å, ä, ö, samt vara mellan 1 och %d bokstäver långt." % \
                             GAZ_PW_LENGTH, \
                             msg.sender)
                return

            # Skall vi lägga till en ny ledtråd?
            m = Gazonk.re_ledtrad.match(msg.message)
            if m and len(self.password) == 0:
                send_message("Skriv in lösenord innan du skriver in ledtrådar.", msg.sender)
                return
            elif m:
                clue = m.group(2)
                if clue != None:
                    self.clues.append(clue)
                    self.tstats.new_clue()
                self.send_clue_message(msg.sender, 1)
                return

            # Skall byta ut en ledtråd?
            m = Gazonk.re_byt_ledtrad.match(msg.message)
            if m and len(self.password) == 0:
                send_message("Skriv in lösenord innan du skriver in ledtrådar.", msg.sender)
                return
            elif m:
                nr = int(m.group(1))
                clue = m.group(2)
                if nr > len(self.clues):
                    send_message("Ledtrådsnumret finns inte.", msg.sender)
                    return
                elif nr > 0:
                    self.clues[nr-1] = clue
                    send_message("Ledtråd %d byttes ut till: %s" % (nr, clue), msg.sender)
                    if nr <= self.current_clue + 1:
                        self.send_next_clue_letter(1)
                    return

            # Visa gissningar för olika personer.
            m = Gazonk.re_gissningar.match(msg.message)
            if m:
                nr = m.group(1)
                if len(nr) == 0:
                    message = "Alla gissningar:\n"
                    message += "----------------------------\n"
                    message += self.current_guesses.create_string(MAX_ENTRIES_GUESS_LIST, "Totalt")
                else:
                    nr = int(nr)
                    if nr < 1 or nr > self.current_clue + 1:
                        message = "Ledtråden är ej given."
                    else:
                        gdb = self.per_clue_guesses[nr-1]
                        message = "Gissningar för ledtråd %d:\n" % nr
                        message += "----------------------------\n"
                        message += print_clue(self.clues[nr-1], nr)
                        message += "\n----------------------------\n"
                        message += gdb.create_string(MAX_ENTRIES_GUESS_LIST)
                send_message(message, msg.sender)
                return

        # Saker som alla får göra:

        # Vem är gazonk?
        m = Gazonk.re_vem.search(msg.message)
        if m:
            if self.person_no > 0:
                gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
                send_message("<Person %d: %s> är gazonk!" % (self.person_no, gaz_name), \
                             msg.sender)
            else:
                send_message("Ingen person är gazonk just nu!", msg.sender)
            return

        # Visa nuvarande ledtrådar
        m = Gazonk.re_visa.search(msg.message)
        if m:
            if self.current_clue == -1:
                send_message("Ingen gazonk-omgång pågår just nu.", msg.sender)
            else:
                self.send_clue_message(msg.sender, 0)
            return

        # Visa när nästa ledtråd kommer
        m = Gazonk.re_nasta.search(msg.message)
        if m:
            current_time = time.time()
            if self.current_clue == -1:
                send_message("Ingen gazonk-omgång pågår just nu.", msg.sender)
                return
            elif current_time - self.time_last_action > GAZONK_CLUE_TIME:
                send_message("Nästa ledtråd borde redan ha sänts, tjata på gazonk!", msg.sender)
                return
            else:
                next_clue_time = self.time_last_action + GAZONK_CLUE_TIME - current_time
                message = "Det är %d timmar och %d minuter kvar till nästa ledtråd" % \
                          divmod(next_clue_time/60,60)
                send_message(message, msg.sender)
                return

        # Visa de 50 senaste lösenorden.
        m = Gazonk.re_gamla_losenord.search(msg.message)
        if m:
            if len(self.password_history) == 0:
                send_message("Inga lösenord har klarats än.",msg.sender)
            message = "De 50 senast använda lösenorden:\n"
            message += "--------------------------------\n"
            for pw in self.password_history:
                message += pw + "\n"
            send_message(message,msg.sender)
            return

        # Statistik om en person.
        m = Gazonk.re_statistik.match(msg.message)
        if m:
            person_str = m.group(1)
            if len(person_str) == 0:
                self.tstats.send_person_stats(msg.sender)
            else:
                operson = find_person(person_str)
                if operson == None:
                    send_message("Hittade ingen eller fler än en sådan person.",msg.sender)
                else:
                    self.tstats.send_person_stats(msg.sender, operson)
            return

        # Saker som alla utom gazonk får göra:
        if self.person_no != msg.sender:
            if self.current_clue == -1:
                send_message("Ingen gazonk-omgång pågår just nu.", msg.sender)
                return
            # Har vi gissat rätt lösenord?
            m = Gazonk.re_gissa.match(msg.message)
            sm = msg.message.strip()

            guess = sm
            if m:
                guess = m.group(1)

            gm = Gazonk.re_gissning.search(guess)
            if not gm:
                send_message("Din gissning godkändes ej.\n\n" + \
                             "Ett lösenord innehåller enbart bokstäverna\n" + \
                             "a-z, å, ä, ö, samt är mellan 1 och %d bokstäver långt." % \
                             GAZ_PW_LENGTH, \
                             msg.sender)
                return


            if guess == self.password:
                # Lägg till gissningen i lite gissningsdatabaser.
                if GAZ_CORRECT_IN_END_MESSAGE == 1:
                    self.current_guesses.add(guess)
                    self.per_clue_guesses[self.current_clue].add(guess)
                self.tstats.add_guess(guess, msg.sender, self, 1, self.current_clue+1)

                self.password_history[0:0] = [self.password]
                self.password_history = self.password_history[0:50]
                send_message("Grattis, Du gissade rätt!\nDu är nu ny gazonk!", msg.sender)
                gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
                new_gaz_name = kom.ReqGetUconfStat(conn, msg.sender).response().name
                mess_subject = "%s gazonkar" % shorten_name(gaz_name)
                mess_text = "<Person %d: %s> klarade lösenordet och är ny gazonk!" % \
                            (msg.sender, new_gaz_name)
                self.send_end_of_round_message(mess_subject, mess_text)
                self.reset()
                self.person_no = msg.sender
                self.set_last_action()
                return
            else:
                # Lägg till gissningen i lite gissningsdatabaser.
                self.current_guesses.add(guess)
                self.per_clue_guesses[self.current_clue].add(guess)
                self.tstats.add_guess(guess, msg.sender, self, 0, 0)
                send_message(random.choice(wrong_guess_list), msg.sender)
                return

        # Detta kommando var inte begripligt
        send_message("Jag begriper inte vad du vill göra!", msg.sender)
        return

class TotStats:
    def __init__(self):
        self.total = Stats(1)
        self.monthly = Stats(0)
        self.cr = Stats(0)
        self.disp_stat = GAZ_DISPLAY_STATISTICS
        self.now = get_now_num(self.disp_stat)

    def reset(self):
        self.reset_now()
        self.monthly.reset()

    def reset_now(self):
        self.disp_stat = GAZ_DISPLAY_STATISTICS
        self.now = get_now_num(self.disp_stat)

    def new_round(self):
        self.cr.new_round()

    def new_given_clue(self):
        self.cr.new_given_clue()

    def new_clue(self):
        self.cr.new_clue()

    def end_round(self):
        self.total.merge_into(self.cr)
        self.monthly.merge_into(self.cr)
        self.cr.reset()

    def add_guess(self, guess, person, g, win = 0, cluenr = 0):
        self.cr.add_guess(guess, person, g, win, cluenr)

    def send_person_stats(self, person, about_person = None):
        if about_person == None:
            if not self.total.people.has_key(person) and \
               not self.cr.people.has_key(person):
                send_message("Du har inte skaffat dig någon statistik än.", person)
            else:
                if self.total.people.has_key(person):
                    nstats = copy.deepcopy(self.total.people[person])
                    if self.cr.people.has_key(person):
                        nstats.merge_into(self.cr.people[person])
                else:
                    nstats = copy.deepcopy(self.cr.people[person])
                nstats.send_person_stats(person)
        else:
            if not self.total.people.has_key(about_person[0]):
                send_message("%s har inte någon statistik än." % about_person[1], person)
            else:
                self.total.people[about_person[0]].send_person_stats(person,about_person)

    def check(self, g):
        if self.disp_stat == 0:
            return
        current = get_now_num(self.disp_stat)
        if current != self.now:
            # It is a new hour/day/week/month/year, so display stats.
            self.monthly.send_stat_letter(self, g)
            self.total.send_stat_letter(self, g)
            self.reset()

class Stats:
    def __init__(self,tot = 1):
        self.guesses = GuessDB()
        self.reset()
        self.total = tot

    def reset(self):
        self.guesses.reset()
        self.people = {}
        self.round_count = 0
        self.given_clue_count = 0
        self.clue_count = 0
        self.acoc = AverageCoC()

    def new_round(self):
        self.round_count += 1

    def new_given_clue(self):
        self.given_clue_count += 1

    def new_clue(self):
        self.clue_count += 1

    def add_guess(self, guess, person, g, win = 0, cluenr = 0):
        self.guesses.add(guess)
        if not self.people.has_key(person):
            self.people[person] = PersonStats()
        self.people[person].add_guess(guess, person, win, cluenr)
        if win == 1:
            self.acoc.add(cluenr)
            if not self.people.has_key(g.person_no):
                self.people[g.person_no] = PersonStats()
            self.people[g.person_no].m_coc_mg.add(cluenr)
            self.people[g.person_no].gpk_coc_mg.add(g.current_guesses.count + 1)

    def merge_into(self, other):
        self.round_count += other.round_count
        self.given_clue_count += other.given_clue_count
        self.clue_count += other.clue_count
        self.guesses.merge_into(other.guesses)
        self.acoc.merge_into(other.acoc)

        plist = other.people.keys()
        for person in plist:
            if not self.people.has_key(person):
                self.people[person] = other.people[person]
            else:
                self.people[person].merge_into(other.people[person])

    def send_stat_letter(self, s, g):
        mstrings = { 1: ("Den", "timme", "timmen"), \
                     2: ("Den", "dag", "dagen"), \
                     3: ("Den", "vecka", "veckan"), \
                     4: ("Den", "månad", "månaden"), \
                     5: ("Det", "år", "året") }
        (dd, mob, mbest) = mstrings[s.disp_stat]

        if self.total == 1:
            subject = "Statistik för Gazonks livstid"
            message = "Gazonks liv startades %s. Sedan dess har %d gazonkningar\n" % \
                      (time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(g.startup_time)), \
                       self.round_count)
            message += "avslutats och det har gjorts totalt %d gissningar på sammanlagt\n" % \
                      self.guesses.count
            message += "%d givna ledtrådar. Totalt %d ledtrådar angavs.\n\n" % \
                       (self.given_clue_count, self.clue_count)
        else:
            subject = "Statistik för den senaste %s." % mbest

            message = "%s senaste %s har %d gazonkningar avslutats och\n" % \
                      (dd, mbest, self.round_count)
            message += "det har gjorts totalt %d gissningar på sammanlagt %d givna\n" % \
                       (self.guesses.count, self.given_clue_count)
            message += "ledtrådar. Totalt %d ledtrådar angavs.\n\n" % \
                       self.clue_count

        acocnum = self.acoc.get()
        if acocnum != None and self.round_count > 0 and self.given_clue_count > 0:
            message += "Antalet ledtrådar som behövts i snitt innan lösenordet klarades\n"
            message += "var %3.1f." % acocnum
            message += " Antal gissningar för att klara ett lösenord var %3.1f\ni snitt." % \
                       (float(self.guesses.count)/float(self.round_count))
            message += " Antal gissningar per given ledtråd var %3.1f.\n\n" % \
                       (float(self.guesses.count)/float(self.given_clue_count))

        message += """Statistik över personer som gissat:
-----------------------------------
 Gissn Korr    k/g   Led GLed   g/k  Gg/k   g/l  Gg/l Person
"""

        plist_tmp = zip(self.people.values(), self.people.keys())
        plist = [(value.win_count, \
                  divide_with_zero(value.win_count, value.guesses.count), \
                  value.guesses.count, key, value) for (value,key) in plist_tmp]
        plist.sort()
        plist.reverse()

        for (korr, kpgn, guesscount, person, pstats) in plist:
            pname = kom.ReqGetUconfStat(conn, person).response().name

            kpg = ""
            if kpgn != None:
                kpg = "%3.2f%%" % (kpgn*100.0)

            nled = pstats.m_coc.get()
            led = ""
            if nled != None:
                led = "%2.1f" % nled

            ngled = pstats.m_coc_mg.get()
            gled = ""
            if ngled != None:
                gled = "%2.1f" % ngled

            ngpk = pstats.gpk_coc.get()
            gpk = ""
            gpl = ""
            if ngpk != None:
                gpk = "%3.1f" % ngpk
                if nled != None:
                    gpl = "%3.1f" % (ngpk/nled)

            nggpk = pstats.gpk_coc_mg.get()
            ggpk = ""
            ggpl = ""
            if nggpk != None:
                ggpk = "%3.1f" % nggpk
                if ngled != None:
                    ggpl = "%3.1f" % (nggpk/ngled)

            row = string.rjust(str(guesscount),6) + " " + \
                  string.rjust(str(korr),4) + " " + \
                  string.rjust(kpg, 7) + " " + \
                  string.rjust(led, 4) + " " + \
                  string.rjust(gled, 4) + " " + \
                  string.rjust(gpk, 5) + " " + \
                  string.rjust(ggpk, 5) + " " + \
                  string.rjust(gpl, 5) + " " + \
                  string.rjust(ggpl, 5) + " " + \
                  pname
            row = row[:72]

            glist = zip(pstats.guesses.db.values(), pstats.guesses.db.keys())
            glist.sort()
            glist.reverse()
            message += row + "\n"

        g.send_letter(subject, message, GAZONK_CONF, 1, 1)

        # Now reset the stats for next period.
        if self.total != 1:
            self.reset()

class PersonStats:
    def __init__(self):
        self.guesses = GuessDB()
        self.reset()

    def reset(self):
        self.guesses.reset()
        self.win_count = 0
        self.m_coc = AverageCoC()
        self.m_coc_mg = AverageCoC()
        self.gpk_coc = AverageCoC()
        self.gpk_coc_mg = AverageCoC()

    def merge_into(self, other):
        self.win_count += other.win_count
        self.guesses.merge_into(other.guesses)
        self.m_coc.merge_into(other.m_coc)
        self.m_coc_mg.merge_into(other.m_coc_mg)
        self.gpk_coc.merge_into(other.gpk_coc)
        self.gpk_coc_mg.merge_into(other.gpk_coc_mg)

    def add_guess(self, guess, person, win = 0, cluenr = 0):
        self.guesses.add(guess)
        if win == 1:
            self.win_count += 1
            self.m_coc.add(cluenr)
            self.gpk_coc.add(self.guesses.count)

    def send_person_stats(self, person_no, about_person = None):
        message = ""
        if about_person != None:
            message = "Statistik om <Person %d: %s>.\n\n" % about_person

        message += "Gissningar:  %d\n" % self.guesses.count
        message += "Korrekta:    %d\n" % self.win_count
        if self.guesses.count > 0:
            message += "k/g:         %3.2f%%\n" % \
                       (float(self.win_count)/float(self.guesses.count)*100.0)
        mc = self.m_coc.get()
        mcmg = self.m_coc_mg.get()
        gpk = self.gpk_coc.get()
        gpkmg = self.gpk_coc_mg.get()
        if mc != None:
            message += "Led:         %2.1f\n" % mc
        if mcmg != None:
            message += "GLed:        %2.1f\n" % (mcmg)
        extra = ""
        if gpk != None:
            message += "g/k:         %3.1f\n" % gpk
            if mc != None:
                extra += "g/l:         %3.1f\n" % (gpk/mc)
        if gpkmg != None:
            message += "Gg/k:        %3.1f\n" % (gpkmg)
            message += extra
            if mcmg != None:
                message += "Gg/l:        %3.1f\n" % (gpkmg/mcmg)
        else:
            message += extra

        message += "\nTop 50 gissningar:\n"
        message += "------------------\n"
        message += self.guesses.create_string(50)
        send_message(message, person_no)

# Liten klass för att hålla reda på ord.
class GuessDB:
    def __init__(self):
        self.db = {}
        self.count = 0

    def reset(self):
        self.db = {}
        self.count = 0

    def add(self, guess):
        self.count += 1
        if not self.db.has_key(guess):
            self.db[guess] = 1
        else:
            self.db[guess] += 1

    def merge_into(self, other):
        self.count += other.count
        og_list = other.db.keys()
        for guess in og_list:
            if not self.db.has_key(guess):
                self.db[guess] = other.db[guess]
            else:
                self.db[guess] += other.db[guess]

    def create_string(self, max_nr = MAX_ENTRIES_GUESS_LIST, total_word = "Sammanlagt"):
        glist = zip(self.db.values(), self.db.keys())
        gtmp = [(-n,s) for n,s in glist]
        gtmp.sort()
        glist = [(-n,s) for n,s in gtmp]

        guess_string = ""
        for (amount, guess) in glist[:max_nr]:
            guess_string += string.ljust(guess, min(GAZ_PW_LENGTH + 9, 60)) + \
                            " " + string.rjust(str(amount), 5) + "\n"
        if self.count == 0:
            guess_string += "Inga gissningar.\n" 
        elif self.count == 1:
            guess_string += "----------------------------\n"
            guess_string += "%s 1 gissning.\n" % total_word
        else:
            guess_string += "----------------------------\n"
            guess_string += "%s %d gissningar.\n" % (total_word, self.count)
        return guess_string

# Klass för att hålla reda på medel för vilken ledtråd som
# det gissades rätt på.
class AverageCoC:
    def __init__(self):
        self.total_clues = 0
        self.amount = 0

    def get(self):
        if self.amount == 0:
            return None
        return float(self.total_clues)/float(self.amount)

    def add(self, clues):
        self.amount += 1
        self.total_clues += clues

    def merge_into(self, other):
        self.amount += other.amount
        self.total_clues += other.total_clues

# Loggning
def log(txt):
    if LOG == 1:
        if txt[-1:] <> "\n":
            txt = txt + "\n"
        logfile.write(txt)
        logfile.flush()

def get_date_and_time():
    return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(time.time()))

# Get current time-number, i.e. hour/day/week/month/year depending on disp_stat
def get_now_num(disp_stat):
    if disp_stat == 0:
        return -1
    tmptime = time.localtime(time.time())
    tmpconv = {0: -1, 1: 3, 2: 2, 3: 6, 4: 1, 5: 0}
    return tmptime[tmpconv[disp_stat]]


# Dela upp en sträng på många rader.
def break_up_row(rstr, row_length = 68):
    nstr = ""
    pos = 0
    while len(rstr[pos:]) > row_length:
        nextpos = rstr.rfind(" ", pos, pos+row_length)
        if nextpos == -1:
            # Can't find a suitable next position, give up.
            break
        nstr += rstr[pos:nextpos] + "\n"
        pos = nextpos+1

    nstr += rstr[pos:]
    return nstr

# Skriv ut en ledtråd på ett snyggt sätt.
def print_clue(s, nr):
    nrstr = str(nr) + ". "
    ns = break_up_row(s, 72-len(nrstr))
    ns = indent(ns, len(nrstr))
    ns = nrstr + ns[len(nrstr):]
    return ns

# Indentering
def indent(txt, spaces):
    lines = string.split(txt, "\n")
    lines = map(lambda line, prefix=" "*spaces: prefix + line, lines)
    return string.join(lines, "\n")

# Skicka ett meddelande
def send_message(message, recipient):
    recipient_name = kom.ReqGetUconfStat(conn, recipient).response().name
    log("%s: Meddelande till %s:" % (get_date_and_time(), recipient_name))
    log(indent(message, 2) + "\n")

    try:
        kom.ReqSendMessage(conn, recipient, message).response()
        kom.ReqUserActive(conn).response()
    except:
        log("Misslyckades med att skicka meddelande.")

# Returnera en person, och endast _en_ person.
def find_person(person_str):
    matches = conn.lookup_name(person_str, 1, 0)
    if len(matches) != 1:
        return None
    else:
        return matches[0]

# Divide
def divide_with_zero(a,b):
    if b > 0:
        return float(a)/float(b)
    else:
        return None

# Förkorta, dvs ta bort pareneteser ur namn
def shorten_name(orig_name):
    #TODO: actually do something
    return orig_name

#
# Huvudkod
#

random.seed()

# Öppna en pidfil och kontrollera att vi inte har någon instans igång.
if PID == 1:
    if os.path.exists(PIDFILE):
        print "There seems to already be a komgazonk running."
        print "If this is not the case, please remove the old pid-file."
        sys.exit(0)
    pidfile = open(PIDFILE, "w")
    pidfile.write(str(os.getpid()))
    pidfile.close()
    os.chmod(PIDFILE, 0600)

# Öppna en logfil, kan vara bra att ha :-)
if LOG == 1:
    logfile = open(LOGFILE, "a")
    log("Starting")

# Skapa en gazonk-information
if os.path.exists(DUMPFILE):
    gaz = cPickle.load(open(DUMPFILE))
else:
    gaz = Gazonk();

# Koppla upp sig, logga in och annat kul
log("Kopplar upp")
conn = kom.CachedConnection(KOMSERVER, port = KOMPORT)
log("Loggar in")
kom.ReqLogin(conn, KOMPERSON, KOMPASSWORD, INVISIBLE).response()
kom.ReqSetClientVersion(conn, CLIENTNAME, VERSION)
log("Gazonk!")

# Se hur lång tid vi har varit nere.
if gaz.current_time >= 0.0:
    gaz.time_last_action += time.time() - gaz.current_time

if GAZ_DISPLAY_STATISTICS != gaz.tstats.disp_stat or \
   GAZ_DISPLAY_STATISTICS < 1:
    gaz.tstats.reset_now()

# Hantera meddelanden

conn.add_async_handler(kom.ASYNC_SEND_MESSAGE, gaz.parse_message)
kom.ReqAcceptAsync(conn, [kom.ASYNC_SEND_MESSAGE]).response()

msleep = MAX_SLEEP_TIME
while 1:
    select.select([conn.socket], [], [], msleep)
    msleep = MAX_SLEEP_TIME
    if gaz.current_time >= 0.0:
        ct = time.time()
        if GAZ_SLEEP_HOURS.count(time.localtime().tm_hour) > 0:
            gaz.time_last_action += ct - gaz.current_time
            msleep = MAX_SLEEP_TIME_NIGHT
    gaz.set_current_time()
    conn.parse_present_data()
    gaz.check_clues()
    gaz.check_monthly()
    gaz.set_current_time()
    cPickle.dump(gaz, open(DUMPFILE, 'w'), DUMPBIN)
