#!/usr/bin/env python

# LysKOM gazonk client

# (C) 2002 Ragnar Ouchterlony. Released under GPL.

# A modern python is necessary for running.
# Tested on python2.2 under solaris and linux.

import kom
import time
import select
import string
import sys
import os
import os.path
import re
from komgazonk_config import *
import cPickle
import random
import copy

CLIENTNAME="komgazonk"
VERSION="0.3.5"

INVISIBLE = 1

MAX_ENTRIES_GUESS_LIST = -1

wrong_guess_list = ["Fel, fel, fel, fel!", \
                    "Nepp!", \
                    "Nähä!", \
                    "Inte alls.", \
                    "Helt fel.", \
                    "Trodde du verkligen att det skulle vara rätt?", \
                    "Om du läser ledtrådarna först går det nog bättre.", \
                    "En daggmask hade kommit på något bättre än det där.", \
                    "Till och med du borde kunna komma på något bättre.", \
                    "Det var ju riktigt nära! Nej, jag bara skojade.", \
                    "Jag hoppas för din skull att det där var en feltryckning.", \
                    "*Gäsp* Säg till när du skall göra en seriös gissning.", \
                    "Du är inte ens nära.", \
                    "Mwhahahahahahahah.", \
                    "Flicka lilla, du kanske borde fråga din mamma?", \
                    "Fet chans, grabbhalva!", \
                    "Där högg du allt i sten.", \
                    "Whoah, ingen dålig gissning!", \
                    "Mmmm, nästan. Försök igen.", \
                    "Du ska gissa med svenska ord, hörrö!", \
                    "Var det där en gissning, eller?", \
                    "Du vet ju inte ens HUR man gissar!", \
                    "Gissa på du, än är det långt kvar.", \
                    "Ta du och vänta på nästa ledtråd.", \
                    "Kom igen om ett par dar, då är en ny gazonk på G.", \
                    "Det där lösenordet var ju gazonk förra veckan.", \
                    "Hörde du det där ordet på radion nyss, eller?", \
                    "I vilken ordbok hittade du den gissningen då?", \
                    "Du fuskar, du har Gooooooglat!!! Men det var ändå fel.", \
                    "Loser!", \
                    "En nyfödd gissar bättre än du.", \
                    "Du är ful, och fel gissar du också!", \
                    "Trodde du ja!", \
                    "Hur många tror du inte har gissat på det före dej då?", \
                    "Ta o lägg ner, va?", \
                    "Så puttinuttigt då... MEN DET ÄR FEEEEL!", \
                    "Hur tänker du då?", \
                    "Du skulle nog svängt vänster där borta... Du är ju helt vilse!", \
                    "Pfft, knappast.", \
                    "Men du är ju hopplös!", \
                    "Skärp dig!", \
                    "Du kanske skulle fråga skräphögen om råd.", \
                    "Det är aldrig försent att ge upp."]

help_strings = {"": """Grundläggande kommandon:
------------------------
'hjälp':              Skicka detta hjälpmeddelande.
'hjälp kommandon':    Skicka ett hjälpmeddelande om vanliga kommandon.
'hjälp gazonk':       Skicka ett hjälpmeddelande om kommandon för gazonk.
'hjälp statistik':    Skicka ett hjälpmeddelande om statistiken.
'gissa <gissning>:    Gissa på lösenordet.
'<gissning>:          Samma som ovan.""", \
                "kommandon": """Vanliga kommandon:
------------------
'vem':                Talar om vem som är gazonk.
'visa':               Listar givna ledtrådar.
'ny gazonk':          Bli gazonk, om ingen är gazonk redan.
'nästa':              Talar om hur långt det är kvar till nästa ledtråd.
'mina gissningar':    Visar en lista på de ord som du gissat på denna omgång.
'gamla lösenord':     Visar en lista på de 50 senaste lösenorden.
'statistik':          Visar lite staitistik om ditt gazonkande.
'statistik <person>': Visar statistik om given person.""", \
                "gazonk": """Kommandon för gazonk:
---------------------
'lösenord':                     Visar lösenord om omgången är startad.
'lösenord <nytt lösenord>':     Byter lösenord då omgång ej är startad.
'ledtråd':                      Visar alla ledtrådar.
'ledtråd <en ledtråd>':         Lägger in en ny ledtråd.
'byt ledtråd <nr> <en ledtråd>: Byter ut en ledtråd mot en annan.
'sätt in ledtråd <nr> <en ledtråd>': Sätter in en ledtråd på given plats.
'ta bort ledtråd <nr>':         Tar bort given ledtråd.
'gissningar':                   Visar alla gissningar för nuvarande
                                gazonkning.
'gissningar personer':          Visar en tabell över vilka som gissat
                                och hur mycket de har gissat.
'gissningar <ledtrådsnr>':      Visar alla gissningar för på den
                                ledtråden.
'tidsintervall <antal>[hms]':   Sätter tidsintervallet som ledtrådar
                                skall komma med.
'återställ tidsintervall':      Återställer tidsintervallet till det det
                                var från början.
'avsäg gazonk':                 Avsäg dig gazonk-titeln.""", \
                "statistik": """Hjälp över statistik-förkortningar:
-----------------------------------
Gissn  = antal gissningar
Korr   = antal korrekta gissningar
k/g    = andel korrekta gissningar (procent)
Led    = antal ledtrådar som behövts i snitt för att klara lösenordet
GLed   = antal ledtrådar motståndarna behövt i snitt för att klara
         lösenordet när personen är gazonk
g/k    = antal gissningar i snitt för att klara ett lösenord
Gg/k   = antal gissningar i snitt motståndarna behöver för att klara
         lösenordet när personen är gazonk
g/l    = antal gissningar i snitt per given ledtråd för att
         klara ett lösenord
Gg/l   = antal gissningar i snitt per given ledtråd motståndarna
         behöver för att klara lösenordet när personen är gazonk
Person = för denna person"""}


class Gazonk:
    re_auto_reply = re.compile("^Auto-reply:", re.IGNORECASE)
    re_ny_gazonk = re.compile("^ny gazonk$", re.IGNORECASE)
    re_losenord_a = re.compile("^l[Öö]senord", re.IGNORECASE)
    re_losenord_b = re.compile("^[Ll][Öö][Ss][Ee][Nn][Oo][Rr][Dd] *([" + GAZ_PW_CHARS + \
                               "]{1," + str(GAZ_PW_LENGTH) + "}) *$")
    re_gissning = re.compile("^[" + GAZ_PW_CHARS + "]{1," + str(GAZ_PW_LENGTH) + "}$")
    re_ledtrad = re.compile("^ledtr[Åå]d( *| +(.+))$", re.IGNORECASE)
    re_byt_ledtrad = re.compile("^byt ledtr[Åå]d +([0-9]+) +(.+)$", re.IGNORECASE)
    re_satt_in_ledtrad = re.compile("^s[Ää]tt in ledtr[Åå]d +([0-9]+) +(.+)$", re.IGNORECASE)
    re_ta_bort_ledtrad = re.compile("^ta bort ledtr[Åå]d +([0-9]+)$", re.IGNORECASE)
    re_gissningar = re.compile("^gissningar *([0-9]*|personer)$", re.IGNORECASE)
    re_mina_gissningar = re.compile("^mina gissningar$", re.IGNORECASE)
    re_tidsintervall = re.compile("^tidsintervall *([0-9]*) *([hms]) *$", re.IGNORECASE)
    re_ater_tidsintervall = re.compile("^[Åå]terst[Ää]ll tidsintervall$", re.IGNORECASE)
    re_avsag_gazonk = re.compile("^avs[Ää]g gazonk$", re.IGNORECASE)
    re_gissa = re.compile("^[Gg][Ii][Ss][Ss][Aa] *(.*) *$")
    re_vem = re.compile("^vem$", re.IGNORECASE)
    re_visa = re.compile("^visa$", re.IGNORECASE)
    re_nasta = re.compile("^n[Ää]sta$", re.IGNORECASE)
    re_hjalp = re.compile("^hj[Ää]lp *(" + string.join(help_strings.keys(),"|") + ")$", \
                          re.IGNORECASE)
    re_gamla_losenord = re.compile("^gamla l[Öö]senord$", re.IGNORECASE)
    re_statistik = re.compile("^statistik *(.*) *$", re.IGNORECASE)

    def __init__(self):
        self.startup_time = time.time()
        self.current_time = time.time()
        self.password_history = []
        self.tstats = TotStats()
        self.current_guesses = GuessDB()
        self.reset()
        self.version = VERSION
        self.is_night = 0
        self.night_started = -1

    def reset(self):
        self.person_no = -1
        self.password = "";
        self.clues = []
        self.current_clue = -1
        self.time_last_action = -1
        self.warnings_sent = 0
        self.last_text_no = -1
        self.current_guesses.reset()
        self.per_clue_guesses = []
        self.current_guessers = {}
        self.current_time_interval = GAZONK_CLUE_TIME

    def set_last_action(self):
        self.time_last_action = time.time()
        if self.is_night:
            self.night_started = self.time_last_action

    def set_current_time(self):
        ct = time.time()
        now_is_night = GAZ_SLEEP_HOURS.count(time.localtime(ct).tm_hour) > 0
        if self.is_night != now_is_night:
            if now_is_night:
                # Natten börjar nu.
                self.night_started = ct
            else:
                # Natten slutar nu.
                # Gör om det till hela timmar.
                start_of_hour = round(ct/3600.0)*3600.0
                gaz.time_last_action += start_of_hour - self.night_started
                self.night_started = -1
            self.is_night = now_is_night
        self.current_time = time.time()

    def create_guess_list_string(self, max_nr = MAX_ENTRIES_GUESS_LIST):
        message = ""
        i = 0
        for gdb in self.per_clue_guesses:
            i += 1
            message += "Gissningar för ledtråd %d:\n" % i
            message += "----------------------------\n"
            message += print_clue(self.clues[i-1], i)
            message += "\n----------------------------\n"
            message += gdb.create_string(MAX_ENTRIES_GUESS_LIST)
            message += "\n"

        message += "Alla gissningar:\n"
        message += "----------------------------\n"
        message += self.current_guesses.create_string(MAX_ENTRIES_GUESS_LIST, "Totalt")
        return message

    def create_clue_string(self, disp_all):
        clues = self.clues
        if disp_all == 0:
            if self.current_clue == -1:
                return "Inga ledtrådar att visa\n"
            clues = clues[:(self.current_clue+1)]
        elif disp_all == 2:
            if self.current_clue == -1:
                return "Inga ledtrådar att visa\n"
            clues = clues[(self.current_clue+1):]

        if len(clues) == 0:
            return "Inga ledtrådar att visa\n"

        clue_string = ""
        i = 0
        if disp_all == 2:
            i = self.current_clue+1
        for c in clues:
            i += 1
            clue_string += print_clue(c, i) + "\n"
        return clue_string

    def create_who_string(self):
        wholist = zip(self.current_guessers.values(), self.current_guessers.keys())

        who_string = "Gissningar fördelade på personer:\n"
        who_string += "---------------------------------\n"
        if len(wholist) == 0:
            return who_string + "Inga personer har gissat.\n"

        wtmp = [(-len(n), kom.ReqGetUconfStat(conn, s).response().name) for (n,s) in wholist]
        wtmp.sort()
        wholist = [(-n,s) for n,s in wtmp]

        for (amount, person_str) in wholist:
            who_string += string.ljust(person_str[0:22], 23) + " " + \
                          string.rjust(str(amount), 4) + "\n"

        return who_string

    def create_next_clues_string(self):
        nc_times = get_next_clue_time(self.time_last_action, \
                                      self.current_time_interval, \
                                      GAZ_AMOUNT_CLUE_TIMES)
        nc_times_str = format_times(nc_times, self.time_last_action)
        cl = self.current_clue + 1
        result = ""
        for tstr in nc_times_str:
            cl += 1
            result += "Ledtråd %d förväntas komma %s.\n" % (cl, tstr)
        return result

    def send_end_of_round_message(self, subject, message):
        self.tstats.end_round()
        message += "\n\nLösenordet var '%s'.\n\n" % self.password
        message += "Givna ledtrådar:\n"
        message += self.create_clue_string(0)
        message += "\nIcke givna ledtrådar:\n"
        message += self.create_clue_string(2) + "\n"
        message += self.create_guess_list_string(MAX_ENTRIES_GUESS_LIST) + "\n"
        message += self.create_who_string()
        self.send_letter(subject, message, GAZONK_CONF, 0, 0)

    def send_next_clue_letter(self, dont_increase = 0):
        new = 0
        if dont_increase == 0:
            self.current_clue += 1
            self.tstats.new_given_clue()
            self.per_clue_guesses.append( GuessDB() )
            if self.current_clue == 0:
                new = 1

        gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
        mess_subject = "%s gazonkar" % shorten_name(gaz_name)
        mess_text = self.create_clue_string(0)
        mess_text += "------------\n" + self.create_next_clues_string()
        self.send_letter(mess_subject, mess_text, GAZONK_CONF, new, 0)

    def send_clue_message(self, recipient, disp_all, extra_message = None):
        send_string = ""
        if extra_message != None:
            send_string = extra_message + "\n\n"
        send_string += "Ledtrådar:\n"
        send_string += "----------\n"
        send_string += self.create_clue_string(disp_all)

        send_message(send_string, recipient)

    def send_letter(self, subject, message, recipient, new, person):
        recipient_name = kom.ReqGetUconfStat(conn, recipient).response().name
        log("%s: Brev till %s:" % (get_date_and_time(), recipient_name))
        log(indent(message, 2) + "\n")

        misc_info = kom.CookedMiscInfo()
        rec = kom.MIRecipient(kom.MIR_TO, recipient)
        misc_info.recipient_list.append(rec)

        if new == 0 and person == 0 and self.last_text_no > 0:
            try:
                ts = conn.textstats[self.last_text_no]
                mic = kom.MICommentTo(kom.MIC_COMMENT, self.last_text_no)
                misc_info.comment_to_list.append(mic)
            except:
                log("Old text number %d not found" % self.last_text_no)

        send_text = subject + "\n" + message
        text_no = kom.ReqCreateText(conn, send_text, misc_info, []).response()
        if person == 0:
            self.last_text_no = text_no

    def check_monthly(self):
        self.tstats.check(self)

    def check_clues(self):
        log("Checking if we should send out clues or warnings.")

        # Skall vi börja en ny omgång?
        if len(self.password) > 0 and \
           len(self.clues) > 0 and \
           self.current_clue == -1:
            self.set_last_action()
            self.send_next_clue_letter()
            self.warnings_sent = 0
            self.tstats.new_round()
            return

        # Om det är natt skall vi inte skicka ut nya ledtrådar och varningar.
        if self.is_night:
            return

        current_time = time.time()
        # Skall vi skicka ut en ny ledtråd?
        if self.current_clue > -1 and \
           len(self.clues) > self.current_clue + 1 and \
           current_time - self.time_last_action > self.current_time_interval:
            self.set_last_action()
            self.send_next_clue_letter()
            self.warnings_sent = 0
            return

        # Dags att skicka ut påminnelse tro?
        if self.person_no > 0 and \
           ((len(self.password) == 0 and len(self.clues) == 0) or \
            len(self.clues) <= self.current_clue + 1) and \
           current_time - self.time_last_action > \
           GAZONK_REMEMBER_TIME * (self.warnings_sent + 1):
            self.warnings_sent += 1

            # Har vi skickat tillräckligt med varningar nu?
            if self.warnings_sent > GAZ_MAX_WARNINGS:
                my_name = kom.ReqGetUconfStat(conn, KOMPERSON).response().name
                gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
                self.send_letter("Du är inte längre gazonk!",
                                 "Du har inte lyssnat på varningarna och blir därmed \n" + \
                                 "fråntagen din gazonktitel!",
                                 self.person_no, 1, 1)
                subject = "%s ej längre gazonk!" % shorten_name(gaz_name)
                message = "Vem som helst kan nu bli gazonk. Skicka bara 'ny gazonk'" + \
                          "\ni ett meddelande till <Person %d: %s>" % (KOMPERSON, my_name)
                if len(self.password) > 0 and len(self.clues) > 0:
                    self.send_end_of_round_message(subject, message)
                else:
                    self.send_letter(subject, message, GAZONK_CONF, 0, 0)
                self.reset()
                return

            # Skicka varningen
            message = "\n\nNu har det gått %d minuter sedan du blev gazonk.\n" % \
                       ((current_time - self.time_last_action)/60)
            message += "Det finns inte tillräckligt med ledtrådar i ledtrådskön.\n\n"
            message += "Det här är varning %d av max %d, sedan kommer din \n" % \
                       (self.warnings_sent, GAZ_MAX_WARNINGS)
            message += "gazonk-titel att fråntas dig!"
            self.send_letter("Detta är en påminnelse om att du är gazonk!",
                             message, self.person_no, 1, 1)
            return

    def parse_message(self, msg, c):
        #Om det inte är till gazonk personligen, skall vi inte svara.
        if msg.recipient != KOMPERSON:
            return

        sender_name = kom.ReqGetUconfStat(conn, msg.sender).response().name
        log("%s: Meddelande (%d) från %s:" % (get_date_and_time(), msg.recipient, sender_name))
        log(indent(msg.message, 2) + "\n")

        # Svara ej på automatsvar.
        m = Gazonk.re_auto_reply.search(msg.message)
        if m:
            return

        # Behöver man hjälp?
        m = Gazonk.re_hjalp.match(msg.message)
        if m:
            send_message(help_strings[m.group(1)], msg.sender)
            return

        # Är detta en request för ny gazonk?
        m = Gazonk.re_ny_gazonk.search(msg.message)
        # Saker som endast kan göras om ingen gazonk finns:
        if m:
            if self.person_no == -1:
                self.reset()
                self.person_no = msg.sender
                self.set_last_action()
                send_message("Du är nu ny gazonk!", msg.sender)
                return
            else:
                send_message("Någon är redan gazonk, så du kan inte bli det!");
                return

        # Saker som endast nuvarande gazonk får göra:
        if self.person_no == msg.sender:
            # Skall vi sätta ett nytt lösenord
            ma = Gazonk.re_losenord_a.search(msg.message)
            mb = Gazonk.re_losenord_b.match(msg.message)
            # Vi får enbart sätta lösenordet om omgången ej är startad än.
            # Skicka tillbaka lösenordet istället.
            if ma and self.current_clue > -1:
                send_message("Har du blivit senil? Nuvarande lösenord är '%s'." % \
                             self.password, \
                             msg.sender)
                return
            elif ma and mb:
                pw = mb.group(1)
                extra_message = ""
                if GAZ_USING_OLD_PASSWORDS > 0 and \
                       self.password_history.count(pw) > 0:
                    if GAZ_USING_OLD_PASSWORDS == 1:
                        extra_message = "Detta lösenord har använts nyligen.\n" \
                                        "Är du säker på att du vill använda det igen?\n\n" \
                                        "Du kan fortfarande ändra på lösenordet om du vill.\n" \
                                        "Använd kommandot 'gamla lösenord' för att se en lista\n" \
                                        "på lösenord som använts nyligen.\n\n"
                    if GAZ_USING_OLD_PASSWORDS == 2:
                        send_message("Detta lösenord har använts nyligen.\n" \
                                     "Detta är inte tillåtet, var snäll och använd ett annat.\n\n" \
                                     "Använd kommandot 'gamla lösenord' för att se en lista\n" \
                                     "på lösenord som använts nyligen.", \
                                     msg.sender)
                        return
                self.password = pw
                self.clues = []
                self.current_clue = -1
                self.time_last_action = -1
                self.warnings_sent = 0
                self.last_text_no = 0
                self.set_last_action()
                send_message(extra_message + "Nytt lösenord är '%s'." % self.password, \
                             msg.sender)
                return
            elif ma:
                send_message("Ditt lösenord godkändes ej.\n\n" + \
                             "Ett lösenord skall enbart innehålla bokstäverna\n" + \
                             "a-z, å, ä, ö, samt vara mellan 1 och %d bokstäver långt." % \
                             GAZ_PW_LENGTH, \
                             msg.sender)
                return

            # Skall vi lägga till en ny ledtråd?
            m = Gazonk.re_ledtrad.match(msg.message)
            if m and len(self.password) == 0:
                send_message("Skriv in lösenord innan du skriver in ledtrådar.", msg.sender)
                return
            elif m:
                clue = m.group(2)
                if clue != None:
                    self.clues.append(clue)
                    self.tstats.new_clue()
                self.send_clue_message(msg.sender, 1)
                return

            # Skall en ledtråd bytas ut?
            m = Gazonk.re_byt_ledtrad.match(msg.message)
            if m and len(self.password) == 0:
                send_message("Skriv in lösenord innan du skriver in ledtrådar.", msg.sender)
                return
            elif m:
                nr = int(m.group(1))
                clue = m.group(2)
                if nr < 1 or nr > len(self.clues):
                    send_message("Ledtrådsnumret finns inte.", msg.sender)
                    return
                elif nr > 0:
                    self.clues[nr-1] = clue
                    message = "Ledtråd %d byttes ut till: %s" % (nr, clue)
                    self.send_clue_message(msg.sender, 1, extra_message = message)
                    if nr <= self.current_clue + 1:
                        self.send_next_clue_letter(1)
                    return

            # Skall en ledtråd sättas in?
            m = Gazonk.re_satt_in_ledtrad.match(msg.message)
            if m and len(self.password) == 0:
                send_message("Skriv in lösenord innan du skriver in ledtrådar.", msg.sender)
                return
            elif m:
                nr = int(m.group(1))
                clue = m.group(2)
                message = ""
                if nr > len(self.clues):
                    self.clues.append(clue)
                    message = "Ledtråden sattes in sist: %s" % clue
                elif nr <= self.current_clue + 1:
                    send_message("Kan inte sätta in en ledtråd där. Det är enbart tillåtet\n" \
                                 "att sätta in ledtrådar efter de som redan visats.", \
                                 msg.sender)
                    return
                else:
                    self.clues[nr-1:nr-1] = [clue]
                    message = "Ledtråden sattes in på position %d: %s" % (nr, clue)

                self.send_clue_message(msg.sender, 1, extra_message = message)
                return


            # Skall en ledtråd tas bort?
            m = Gazonk.re_ta_bort_ledtrad.match(msg.message)
            if m and len(self.password) == 0:
                send_message("Skriv in lösenord innan du skriver in ledtrådar.", msg.sender)
                return
            elif m:
                nr = int(m.group(1))
                message = ""
                if nr < 1 or nr > len(self.clues):
                    send_message("Ledtråden finns inte och kan därmed inte tas bort.", \
                                 msg.sender)
                    return
                elif nr <= self.current_clue + 1:
                    send_message("Kan inte ta bort en ledtråd där. Det är enbart tillåtet\n" \
                                 "att ta bort ledtrådar efter de som redan visats.", \
                                 msg.sender)
                    return
                else:
                    self.clues[nr-1:nr] = []
                    message = "Tog bort ledtråd nummer %d." % nr

                self.send_clue_message(msg.sender, 1, extra_message = message)
                return

            # Visa gissningar för olika personer.
            m = Gazonk.re_gissningar.match(msg.message)
            if m:
                nr = m.group(1)
                if len(nr) == 0:
                    message = "Alla gissningar:\n"
                    message += "----------------------------\n"
                    message += self.current_guesses.create_string(MAX_ENTRIES_GUESS_LIST, "Totalt")
                elif nr == "personer":
                    message = self.create_who_string()
                else:
                    nr = int(nr)
                    if nr < 1 or nr > self.current_clue + 1:
                        message = "Ledtråden är ej given."
                    else:
                        gdb = self.per_clue_guesses[nr-1]
                        message = "Gissningar för ledtråd %d:\n" % nr
                        message += "----------------------------\n"
                        message += print_clue(self.clues[nr-1], nr)
                        message += "\n----------------------------\n"
                        message += gdb.create_string(MAX_ENTRIES_GUESS_LIST)
                send_message(message, msg.sender)
                return

            # Avsäga sig gazonktiteln.
            m = Gazonk.re_avsag_gazonk(msg.message)
            if m:
                if self.current_clue == -1:
                    my_name = kom.ReqGetUconfStat(conn, KOMPERSON).response().name
                    gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
                    subject = "%s har avsagt sig gazonk!" % shorten_name(gaz_name)
                    message = "Vem som helst kan nu bli gazonk. Skicka bara 'ny gazonk'" + \
                              "\ni ett meddelande till <Person %d: %s>" % (KOMPERSON, my_name)
                    self.send_letter(subject, message, GAZONK_CONF, 0, 0)
                    self.reset()
                    return
                else:
                    send_message("Du kan inte avsäga dig en pågående omgång.", msg.sender)
                    return

            # Ställ om tidsintervallet.
            new_interval = 0
            m = Gazonk.re_tidsintervall.match(msg.message)
            if m:
                amount = int(m.group(1))
                hms = m.group(2)
                if hms == "h":
                    amount *= 3600
                elif hms == "m":
                    amount *= 60

                amount = min(amount, GAZONK_CT_MAXIMUM)
                amount = max(amount, GAZONK_CT_MINIMUM)
                new_interval = amount

            # Ställ tillbaka tidsintervallet.
            m = Gazonk.re_ater_tidsintervall.search(msg.message)
            if m:
                new_interval = GAZONK_CLUE_TIME

            if new_interval > 0:
                if new_interval != self.current_time_interval:
                    self.current_time_interval = new_interval
                    ti_format = format_hms(self.current_time_interval, 2)
                    send_message("Tidsintervallet är nu %s mellan varje ledtråd." % ti_format, \
                                 msg.sender)
                    # Sänd ett brev om en gazonk-omgång pågår.
                    if self.current_clue > -1:
                        gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
                        subject = "%s gazonkar" % shorten_name(gaz_name)
                        message = "Tidsintervallet mellan ledtrådar har ändrats och \när nu %s\n\n" % \
                                  ti_format
                        message += self.create_next_clues_string()
                        self.send_letter(subject, message, GAZONK_CONF, 0, 0)
                else:
                    send_message("Tidsintervallet är samma som förut. Ingen förändring.", \
                                 msg.sender)
                return

        # Saker som alla får göra:

        # Vem är gazonk?
        m = Gazonk.re_vem.search(msg.message)
        if m:
            if self.person_no > 0:
                gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
                send_message("<Person %d: %s> är gazonk!" % (self.person_no, gaz_name), \
                             msg.sender)
            else:
                send_message("Ingen person är gazonk just nu!", msg.sender)
            return

        # Visa nuvarande ledtrådar
        m = Gazonk.re_visa.search(msg.message)
        if m:
            if self.current_clue == -1:
                send_message("Ingen gazonk-omgång pågår just nu.", msg.sender)
            else:
                self.send_clue_message(msg.sender, 0)
            return

        # Visa när nästa ledtråd kommer
        m = Gazonk.re_nasta.search(msg.message)
        if m:
            current_time = time.time()
            if self.current_clue == -1:
                send_message("Ingen gazonk-omgång pågår just nu.", msg.sender)
            else:
                nc_times = get_next_clue_time(self.time_last_action, \
                                              self.current_time_interval, \
                                              GAZ_AMOUNT_CLUE_TIMES)

                if nc_times[0] < current_time:
                    send_message("Nästa ledtråd borde redan ha sänts, tjata på gazonk!", \
                                 msg.sender)
                else:
                    time_left = nc_times[0] - current_time
                    message = "Det är %s kvar till nästa ledtråd.\n\n" % \
                              format_hms(time_left,1)
                    nc_times_str = format_times(nc_times[1:], nc_times[0])
                    cl = self.current_clue + 2
                    for tstr in nc_times_str:
                        cl += 1
                        message += "Ledtråd %d förväntas komma %s.\n" % (cl,tstr)
                    send_message(message, msg.sender)
            return

        # Visa vad personen gissat på.
        m = Gazonk.re_mina_gissningar.search(msg.message)
        if m:
            if msg.sender == self.person_no:
                send_message("Du är gazonk och kan därmed inte gissa.", msg.sender)
                return
            if self.current_guessers.has_key(msg.sender):
                message = "Dina gissningar:\n"
                for g in self.current_guessers[msg.sender]:
                    if len(g) > 0:
                        message += g + "\n"
                send_message(message, msg.sender)
            else:
                send_message("Du har inte gissat än.", msg.sender)
            return

        # Visa de 50 senaste lösenorden.
        m = Gazonk.re_gamla_losenord.search(msg.message)
        if m:
            if len(self.password_history) == 0:
                send_message("Inga lösenord har klarats än.",msg.sender)
            message = "De 50 senast använda lösenorden:\n"
            message += "--------------------------------\n"
            for pw in self.password_history:
                message += pw + "\n"
            send_message(message,msg.sender)
            return

        # Statistik om en person.
        m = Gazonk.re_statistik.match(msg.message)
        if m:
            person_str = m.group(1)
            if len(person_str) == 0:
                self.tstats.send_person_stats(msg.sender)
            else:
                operson = find_person(person_str)
                if operson == None:
                    send_message("Hittade ingen eller fler än en sådan person.",msg.sender)
                else:
                    self.tstats.send_person_stats(msg.sender, operson)
            return

        # Saker som alla utom gazonk får göra:
        if self.person_no != msg.sender:
            if self.current_clue == -1:
                send_message("Ingen gazonk-omgång pågår just nu.", msg.sender)
                return
            # Har vi gissat rätt lösenord?
            m = Gazonk.re_gissa.match(msg.message)
            sm = msg.message.strip()

            guess = sm
            if m:
                guess = m.group(1)

            gm = Gazonk.re_gissning.search(guess)
            if not gm:
                send_message("Din gissning godkändes ej.\n\n" + \
                             "Ett lösenord innehåller enbart bokstäverna\n" + \
                             "a-z, å, ä, ö, samt är mellan 1 och %d bokstäver långt." % \
                             GAZ_PW_LENGTH, \
                             msg.sender)
                return

            # Lägg till en gissning för denna omgång för personen i fråga.
            if self.current_guessers.has_key(msg.sender):
                p_guesses = self.current_guessers[msg.sender]
                if p_guesses.count(guess) > 0:
                    send_message("Har du fått alzheimer? Det gissade du ju på nyss ju!\n" +
                                 "Tur för dig att man bara får gissa på samma ord en gång!",
                                 msg.sender)
                    return
                self.current_guessers[msg.sender].append(guess)
            else:
                self.current_guessers[msg.sender] = [guess]

            if guess == self.password:
                # Lägg till gissningen i lite gissningsdatabaser.
                if GAZ_CORRECT_IN_END_MESSAGE == 1:
                    self.current_guesses.add(guess)
                    self.per_clue_guesses[self.current_clue].add(guess)
                self.tstats.add_guess(guess, msg.sender, self, 1, self.current_clue+1)

                self.password_history[0:0] = [self.password]
                self.password_history = self.password_history[0:50]
                send_message("Grattis, Du gissade rätt!\nDu är nu ny gazonk!", msg.sender)
                gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
                new_gaz_name = kom.ReqGetUconfStat(conn, msg.sender).response().name
                mess_subject = "%s gazonkar" % shorten_name(gaz_name)
                mess_text = "<Person %d: %s> klarade lösenordet och är ny gazonk!" % \
                            (msg.sender, new_gaz_name)
                self.send_end_of_round_message(mess_subject, mess_text)
                self.reset()
                self.person_no = msg.sender
                self.set_last_action()
                return
            else:
                # Lägg till gissningen i lite gissningsdatabaser.
                self.current_guesses.add(guess)
                self.per_clue_guesses[self.current_clue].add(guess)
                self.tstats.add_guess(guess, msg.sender, self, 0, 0)
                send_message(random.choice(wrong_guess_list), msg.sender)
                return

        # Detta kommando var inte begripligt
        send_message("Jag begriper inte vad du vill göra!", msg.sender)
        return

class TotStats:
    def __init__(self):
        self.total = Stats(1)
        self.monthly = Stats(0)
        self.cr = Stats(0)
        self.disp_stat = GAZ_DISPLAY_STATISTICS
        self.now = get_now_num(self.disp_stat)

    def reset(self):
        self.reset_now()
        self.monthly.reset()

    def reset_now(self):
        self.disp_stat = GAZ_DISPLAY_STATISTICS
        self.now = get_now_num(self.disp_stat)

    def new_round(self):
        self.cr.new_round()

    def new_given_clue(self):
        self.cr.new_given_clue()

    def new_clue(self):
        self.cr.new_clue()

    def end_round(self):
        self.total.merge_into(self.cr)
        self.monthly.merge_into(self.cr)
        self.cr.reset()

    def add_guess(self, guess, person, g, win = 0, cluenr = 0):
        self.cr.add_guess(guess, person, g, win, cluenr)

    def send_person_stats(self, person, about_person = None):
        if about_person == None:
            if not self.total.people.has_key(person) and \
               not self.cr.people.has_key(person):
                send_message("Du har inte skaffat dig någon statistik än.", person)
            else:
                if self.total.people.has_key(person):
                    nstats = copy.deepcopy(self.total.people[person])
                    if self.cr.people.has_key(person):
                        nstats.merge_into(self.cr.people[person])
                else:
                    nstats = copy.deepcopy(self.cr.people[person])
                nstats.send_person_stats(person)
        else:
            if not self.total.people.has_key(about_person[0]):
                send_message("%s har inte någon statistik än." % about_person[1], person)
            else:
                self.total.people[about_person[0]].send_person_stats(person,about_person)

    def check(self, g):
        if self.disp_stat == 0:
            return
        current = get_now_num(self.disp_stat)
        if current != self.now:
            # It is a new hour/day/week/month/year, so display stats.
            self.monthly.send_stat_letter(self, g)
            self.total.send_stat_letter(self, g)
            self.reset()

class Stats:
    def __init__(self,tot = 1):
        self.guesses = GuessDB()
        self.reset()
        self.total = tot

    def reset(self):
        self.guesses.reset()
        self.people = {}
        self.round_count = 0
        self.given_clue_count = 0
        self.clue_count = 0
        self.acoc = AverageCoC()

    def new_round(self):
        self.round_count += 1

    def new_given_clue(self):
        self.given_clue_count += 1

    def new_clue(self):
        self.clue_count += 1

    def add_guess(self, guess, person, g, win = 0, cluenr = 0):
        self.guesses.add(guess)
        if not self.people.has_key(person):
            self.people[person] = PersonStats()
        self.people[person].add_guess(guess, person, win, cluenr)
        if win == 1:
            self.acoc.add(cluenr)
            if not self.people.has_key(g.person_no):
                self.people[g.person_no] = PersonStats()
            self.people[g.person_no].m_coc_mg.add(cluenr)
            self.people[g.person_no].gpk_coc_mg.add(g.current_guesses.count)

    def merge_into(self, other):
        self.round_count += other.round_count
        self.given_clue_count += other.given_clue_count
        self.clue_count += other.clue_count
        self.guesses.merge_into(other.guesses)
        self.acoc.merge_into(other.acoc)

        plist = other.people.keys()
        for person in plist:
            if not self.people.has_key(person):
                self.people[person] = other.people[person]
            else:
                self.people[person].merge_into(other.people[person])

    def send_stat_letter(self, s, g):
        mstrings = { 1: ("Den", "timme", "timmen"), \
                     2: ("Den", "dag", "dagen"), \
                     3: ("Den", "vecka", "veckan"), \
                     4: ("Den", "månad", "månaden"), \
                     5: ("Det", "år", "året") }
        (dd, mob, mbest) = mstrings[s.disp_stat]

        if self.total == 1:
            subject = "Statistik för Gazonks livstid"
            message = "Gazonks liv startades %s. Sedan dess har %d gazonkningar\n" % \
                      (time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(g.startup_time)), \
                       self.round_count)
            message += "avslutats och det har gjorts totalt %d gissningar på sammanlagt\n" % \
                      self.guesses.count
            message += "%d givna ledtrådar. Totalt %d ledtrådar angavs.\n\n" % \
                       (self.given_clue_count, self.clue_count)
        else:
            subject = "Statistik för den senaste %s." % mbest

            message = "%s senaste %s har %d gazonkningar avslutats och\n" % \
                      (dd, mbest, self.round_count)
            message += "det har gjorts totalt %d gissningar på sammanlagt %d givna\n" % \
                       (self.guesses.count, self.given_clue_count)
            message += "ledtrådar. Totalt %d ledtrådar angavs.\n\n" % \
                       self.clue_count

        acocnum = self.acoc.get()
        if acocnum != None and self.round_count > 0 and self.given_clue_count > 0:
            message += "Antalet ledtrådar som behövts i snitt innan lösenordet klarades\n"
            message += "var %3.1f." % acocnum
            message += " Antal gissningar för att klara ett lösenord var %3.1f\ni snitt." % \
                       (float(self.guesses.count)/float(self.round_count))
            message += " Antal gissningar per given ledtråd var %3.1f.\n\n" % \
                       (float(self.guesses.count)/float(self.given_clue_count))

        message += """Statistik över personer som gissat:
-----------------------------------
 Gissn Korr    k/g   Led GLed   g/k  Gg/k   g/l  Gg/l Person
"""

        plist_tmp = zip(self.people.values(), self.people.keys())
        plist = [(value.win_count, \
                  divide_with_zero(value.win_count, value.guesses.count), \
                  value.guesses.count, key, value) for (value,key) in plist_tmp]
        plist.sort()
        plist.reverse()

        for (korr, kpgn, guesscount, person, pstats) in plist:
            pname = kom.ReqGetUconfStat(conn, person).response().name

            kpg = ""
            if kpgn != None:
                kpg = "%3.2f%%" % (kpgn*100.0)

            nled = pstats.m_coc.get()
            led = ""
            if nled != None:
                led = "%2.1f" % nled

            ngled = pstats.m_coc_mg.get()
            gled = ""
            if ngled != None:
                gled = "%2.1f" % ngled

            ngpk = pstats.gpk_coc.get()
            gpk = ""
            gpl = ""
            if ngpk != None:
                gpk = "%3.1f" % ngpk
                if nled != None:
                    gpl = "%3.1f" % (ngpk/nled)

            nggpk = pstats.gpk_coc_mg.get()
            ggpk = ""
            ggpl = ""
            if nggpk != None:
                ggpk = "%3.1f" % nggpk
                if ngled != None:
                    ggpl = "%3.1f" % (nggpk/ngled)

            row = string.rjust(str(guesscount),6) + " " + \
                  string.rjust(str(korr),4) + " " + \
                  string.rjust(kpg, 7) + " " + \
                  string.rjust(led, 4) + " " + \
                  string.rjust(gled, 4) + " " + \
                  string.rjust(gpk, 5) + " " + \
                  string.rjust(ggpk, 5) + " " + \
                  string.rjust(gpl, 5) + " " + \
                  string.rjust(ggpl, 5) + " " + \
                  pname
            row = row[:72]

            glist = zip(pstats.guesses.db.values(), pstats.guesses.db.keys())
            glist.sort()
            glist.reverse()
            message += row + "\n"

        g.send_letter(subject, message, GAZONK_CONF, 1, 1)

        # Now reset the stats for next period.
        if self.total != 1:
            self.reset()

class PersonStats:
    def __init__(self):
        self.guesses = GuessDB()
        self.reset()

    def reset(self):
        self.guesses.reset()
        self.win_count = 0
        self.m_coc = AverageCoC()
        self.m_coc_mg = AverageCoC()
        self.gpk_coc = AverageCoC()
        self.gpk_coc_mg = AverageCoC()

    def merge_into(self, other):
        self.win_count += other.win_count
        self.guesses.merge_into(other.guesses)
        self.m_coc.merge_into(other.m_coc)
        self.m_coc_mg.merge_into(other.m_coc_mg)
        self.gpk_coc.merge_into(other.gpk_coc)
        self.gpk_coc_mg.merge_into(other.gpk_coc_mg)

    def add_guess(self, guess, person, win = 0, cluenr = 0):
        self.guesses.add(guess)
        if win == 1:
            self.win_count += 1
            self.m_coc.add(cluenr)
            self.gpk_coc.add(self.guesses.count)

    def send_person_stats(self, person_no, about_person = None):
        message = ""
        if about_person != None:
            message = "Statistik om <Person %d: %s>.\n\n" % about_person

        message += "Gissningar:  %d\n" % self.guesses.count
        message += "Korrekta:    %d\n" % self.win_count
        if self.guesses.count > 0:
            message += "k/g:         %3.2f%%\n" % \
                       (float(self.win_count)/float(self.guesses.count)*100.0)
        mc = self.m_coc.get()
        mcmg = self.m_coc_mg.get()
        gpk = self.gpk_coc.get()
        gpkmg = self.gpk_coc_mg.get()
        if mc != None:
            message += "Led:         %2.1f\n" % mc
        if mcmg != None:
            message += "GLed:        %2.1f\n" % (mcmg)
        extra = ""
        if gpk != None:
            message += "g/k:         %3.1f\n" % gpk
            if mc != None:
                extra += "g/l:         %3.1f\n" % (gpk/mc)
        if gpkmg != None:
            message += "Gg/k:        %3.1f\n" % (gpkmg)
            message += extra
            if mcmg != None:
                message += "Gg/l:        %3.1f\n" % (gpkmg/mcmg)
        else:
            message += extra

        message += "\nTop 50 gissningar (fler än 2):\n"
        message += "------------------\n"
        message += self.guesses.create_string(50, min_amount = 2)
        send_message(message, person_no)

# Liten klass för att hålla reda på ord.
class GuessDB:
    def __init__(self):
        self.db = {}
        self.count = 0

    def reset(self):
        self.db = {}
        self.count = 0

    def add(self, guess):
        self.count += 1
        if not self.db.has_key(guess):
            self.db[guess] = 1
        else:
            self.db[guess] += 1

    def merge_into(self, other):
        self.count += other.count
        og_list = other.db.keys()
        for guess in og_list:
            if not self.db.has_key(guess):
                self.db[guess] = other.db[guess]
            else:
                self.db[guess] += other.db[guess]

    def create_string(self, max_nr = -1, \
                      total_word = "Sammanlagt", min_amount = -1):
        glist = zip(self.db.values(), self.db.keys())
        if min_amount > 0:
            glist = filter( (lambda (x,y): x >= min_amount), glist )

        gtmp = [(-n,s) for n,s in glist]
        gtmp.sort()
        glist = [(-n,s) for n,s in gtmp]

        if max_nr > 0:
            glist = glist[:max_nr]
        guess_string = ""
        for (amount, guess) in glist:
            guess_string += string.ljust(guess, min(GAZ_PW_LENGTH + 9, 60)) + \
                            " " + string.rjust(str(amount), 5) + "\n"
        if self.count == 0:
            guess_string += "Inga gissningar.\n" 
        elif self.count == 1:
            guess_string += "----------------------------\n"
            guess_string += "%s 1 gissning.\n" % total_word
        else:
            guess_string += "----------------------------\n"
            guess_string += "%s %d gissningar.\n" % (total_word, self.count)
        return guess_string

# Klass för att hålla reda på medel för vilken ledtråd som
# det gissades rätt på.
class AverageCoC:
    def __init__(self):
        self.total_clues = 0
        self.amount = 0

    def get(self):
        if self.amount == 0:
            return None
        return float(self.total_clues)/float(self.amount)

    def add(self, clues):
        self.amount += 1
        self.total_clues += clues

    def merge_into(self, other):
        self.amount += other.amount
        self.total_clues += other.total_clues

# Loggning
def log(txt):
    if LOG == 1:
        if txt[-1:] <> "\n":
            txt = txt + "\n"
        logfile.write(txt)
        logfile.flush()

def get_date_and_time():
    return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(time.time()))

# Get current time-number, i.e. hour/day/week/month/year depending on disp_stat
def get_now_num(disp_stat):
    if disp_stat == 0:
        return -1
    tmptime = time.localtime(time.time())
    tmpconv = {0: -1, 1: 3, 2: 2, 3: 6, 4: 1, 5: 0}
    return tmptime[tmpconv[disp_stat]]


# Dela upp en sträng på många rader.
def break_up_row(rstr, row_length = 68):
    nstr = ""
    pos = 0
    while len(rstr[pos:]) > row_length:
        nextpos = rstr.rfind(" ", pos, pos+row_length)
        if nextpos == -1:
            # Can't find a suitable next position, give up.
            break
        nstr += rstr[pos:nextpos] + "\n"
        pos = nextpos+1

    nstr += rstr[pos:]
    return nstr

# Skriv ut en ledtråd på ett snyggt sätt.
def print_clue(s, nr):
    nrstr = str(nr) + ". "
    ns = break_up_row(s, 72-len(nrstr))
    ns = indent(ns, len(nrstr))
    ns = nrstr + ns[len(nrstr):]
    return ns

# Indentering
def indent(txt, spaces):
    lines = string.split(txt, "\n")
    lines = map(lambda line, prefix=" "*spaces: prefix + line, lines)
    return string.join(lines, "\n")

# Skicka ett meddelande
def send_message(message, recipient):
    recipient_name = kom.ReqGetUconfStat(conn, recipient).response().name
    log("%s: Meddelande till %s:" % (get_date_and_time(), recipient_name))
    log(indent(message, 2) + "\n")

    try:
        kom.ReqSendMessage(conn, recipient, message).response()
        kom.ReqUserActive(conn).response()
    except:
        log("Misslyckades med att skicka meddelande.")

# Returnera en person, och endast _en_ person.
def find_person(person_str):
    matches = conn.lookup_name(person_str, 1, 0)
    if len(matches) != 1:
        return None
    else:
        return matches[0]

# Formattera en tidssträng på ett käckt sätt.
def format_hms(sec_amount, secs_method = 1):
    (mins, secs) = divmod(int(round(sec_amount)),60)
    hours = 0
    if mins >= 60:
        (hours, mins) = divmod(mins,60)

    parts = []
    if hours > 0:
        hstring = "timme"
        if hours > 1:
            hstring = "timmar"
        parts.append( "%d %s" % (hours, hstring) )

    if mins > 0:
        mstring = "minut"
        if mins > 1:
            mstring = "minuter"
        parts.append( "%d %s" % (mins, mstring) )

    if ((secs_method == 1 and sec_amount < 180) or secs_method == 2) and \
       (secs > 0 or (hours == 0 and mins == 0 and secs == 0)):
        sstring = "sekund"
        if secs == 0 or secs > 1:
            sstring = "sekunder"
        parts.append( "%d %s" % (secs, sstring) )

    if len(parts) == 3:
        return "%s, %s och %s" % (parts[0], parts[1], parts[2])
    elif len(parts) == 2:
        return "%s och %s" % (parts[0], parts[1])

    return "%s" % (parts[0])

# Formattera en sträng av varje tid på ett fint sätt ("10:40 imorgon" t.ex.)
def format_times(time_list, relative_to_time):
    rtt = relative_to_time
    result = []
    for t in time_list:
        tl = time.localtime(t)
        time_string = "%s:%s" % (string.zfill(str(tl.tm_hour), 2), \
                                 string.zfill(str(tl.tm_min), 2))
        day_diff = t // 86400 - rtt // 86400
        if day_diff > 0:
            if day_diff == 1:
                time_string += " nästa dag"
            else:
                time_string += " %d dagar senare" % day_diff
        rtt = t
        result.append(time_string)
    return result

# Tar utifrån föregående tid och tidsintervallet reda på när nästa ledtråd borde komma.
def get_next_clue_time(start_time, time_interval, amount):
    from_time = start_time
    now = time.time()
    if GAZ_SLEEP_HOURS.count(time.localtime(start_time).tm_hour) > 0:
        from_time -= float(time.localtime(start_time).tm_min)*60.0
    result = []
    for nr in range(amount):
        cur_hour = time.localtime(from_time).tm_hour
        end_hour = cur_hour + int(time_interval)/3600
        if divmod(end_hour,24)[1] != time.localtime( from_time + float(time_interval) ).tm_hour:
            end_hour += 1
        add_hours = 0
        while cur_hour <= end_hour:
            if GAZ_SLEEP_HOURS.count(divmod(cur_hour,24)[1]) > 0:
                end_hour += 1
                add_hours += 1
            cur_hour += 1
        end_time = from_time + float(time_interval) + float(add_hours)*3600.0
        if end_time < now:
            end_time = now
        result.append( end_time )
        from_time = end_time
    return result

# Divide
def divide_with_zero(a,b):
    if b > 0:
        return float(a)/float(b)
    else:
        return None

# Förkorta, dvs ta bort pareneteser ur namn
def shorten_name(orig_name):
    #TODO: actually do something
    return orig_name

#
# Huvudkod
#

random.seed()

# Öppna en pidfil och kontrollera att vi inte har någon instans igång.
if PID == 1:
    if os.path.exists(PIDFILE):
        print "There seems to already be a komgazonk running."
        print "If this is not the case, please remove the old pid-file."
        sys.exit(0)
    pidfile = open(PIDFILE, "w")
    pidfile.write(str(os.getpid()))
    pidfile.close()
    os.chmod(PIDFILE, 0600)

# Öppna en logfil, kan vara bra att ha :-)
if LOG == 1:
    logfile = open(LOGFILE, "a")
    log("Starting")

# Skapa en gazonk-information
if os.path.exists(DUMPFILE):
    log("Loading dumpfile")
    gaz = cPickle.load(open(DUMPFILE))

    # Kolla dump-filens versionsnummer för att se om funktionalitet lagts
    # till sedan dess. Om inget versionsnummer finnes antas det vara
    # 0.2.3 (dvs sista versionen utan versionsnummer inbyggt).
    old_version = getattr(gaz, "version", "0.2.3")
    if old_version != VERSION:
        log("Converting dumpfile of version %s to be uptodate." % old_version)
        # Dumpfilen är gjord av en gammal komgazonk. Uppgradera!
        old_version = [int(x) for x in old_version.split(".")]
        # Om gamla versionsnumret är mindre än 0.3.0
        if old_version < [0,3,0]:
            log("Add things from version 0.3.0.")
            gaz.is_night = 0
            gaz.night_started = -1
            gaz.current_time_interval = GAZONK_CLUE_TIME
            gaz.current_guessers = {}

        # Om vi har en version som är mindre än 0.3.5
        if old_version < [0,3,5]:
            tmpx = zip(gaz.current_guessers.keys(), gaz.current_guessers.values())
            gaz.current_guessers = dict([(x,['']*y) for (x,y) in tmpx])

        # Uppdatera versionsnumret
        gaz.version = VERSION
else:
    gaz = Gazonk();

# Koppla upp sig, logga in och annat kul
log("Kopplar upp")
conn = kom.CachedConnection(KOMSERVER, port = KOMPORT)
log("Loggar in")
kom.ReqLogin(conn, KOMPERSON, KOMPASSWORD, INVISIBLE).response()
kom.ReqSetClientVersion(conn, CLIENTNAME, VERSION)
log("Gazonk!")

# Den tiden vi varit nere skall inte räknas.
if gaz.current_time >= 0.0:
    gaz.time_last_action += time.time() - gaz.current_time
    if gaz.night_started != -1:
        gaz.night_started += time.time() - gaz.current_time

if GAZ_DISPLAY_STATISTICS != gaz.tstats.disp_stat or \
   GAZ_DISPLAY_STATISTICS < 1:
    gaz.tstats.reset_now()

# Hantera meddelanden

conn.add_async_handler(kom.ASYNC_SEND_MESSAGE, gaz.parse_message)
kom.ReqAcceptAsync(conn, [kom.ASYNC_SEND_MESSAGE]).response()

msleep = MAX_SLEEP_TIME
while 1:
    select.select([conn.socket], [], [], msleep)
    msleep = MAX_SLEEP_TIME
    gaz.set_current_time()
    conn.parse_present_data()
    gaz.check_clues()
    gaz.check_monthly()
    gaz.set_current_time()
    if gaz.is_night:
        msleep = MAX_SLEEP_TIME_NIGHT
    cPickle.dump(gaz, open(DUMPFILE, 'w'), DUMPBIN)
