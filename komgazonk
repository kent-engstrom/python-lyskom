#!/usr/bin/env python

# LysKOM gazonk client

# (C) 2002 Ragnar Ouchterlony. Released under GPL.

import kom
import time
import select
import string
import os
import os.path
import re
from komgazonk_config import *
import cPickle
import random

CLIENTNAME="komgazonk"
VERSION="0.1.1"

INVISIBLE = 1

MAX_ENTRIES_GUESS_LIST = 200

wrong_guess_list = ["Fel, fel, fel, fel!", \
                    "Nepp!", \
                    "Nähä!", \
                    "Inte alls.", \
                    "Helt fel.", \
                    "Trodde du verkligen att det skulle vara rätt?", \
                    "Om du läser ledtrådarna först går det nog bättre.", \
                    "En daggmask hade kommit på något bättre än det där.", \
                    "Till och med du borde kunna komma på något bättre.", \
                    "Det var ju riktigt nära! Nej, jag bara skojade.", \
                    "Jag hoppas för din skull att det där var en feltryckning.", \
                    "*Gäsp* Säg till när du skall göra en seriös gissning.", \
                    "Du är inte ens nära.", \
                    "Mwhahahahahahahah.", \
                    "Flicka lilla, du kanske borde fråga din mamma?", \
                    "Fet chans, grabbhalva!", \
                    "Där högg du allt i sten.", \
                    "Whoah, ingen dålig gissning!", \
                    "Mmmm, nästan. Försök igen.", \
                    "Du ska gissa med svenska ord, hörrö!", \
                    "Var det där en gissning, eller?", \
                    "Du vet ju inte ens HUR man gissar!", \
                    "Gissa på du, än är det långt kvar.", \
                    "Ta du och vänta på nästa ledtråd.", \
                    "Kom igen om ett par dar, då är en ny gazonk på G.", \
                    "Det där lösenordet var ju gazonk förra veckan.", \
                    "Det där har någon annan redan gissat på.", \
                    "Hörde du det där ordet på radion nyss, eller?", \
                    "I vilken ordbok hittade du den gissningen då?", \
                    "Du fuskar, du har Gooooooglat!!! Men det var ändå fel.", \
                    "Loser!", \
                    "En nyfödd gissar bättre än du.", \
                    "Du är ful, och fel gissar du också!", \
                    "Trodde du ja!", \
                    "Hur många tror du inte har gissat på det före dej då?", \
                    "Ta o lägg ner, va?", \
                    "Så puttinuttigt då... MEN DET ÄR FEEEEL!", \
                    "Hur tänker du då?", \
                    "Du skulle nog svängt vänster där borta... Du är ju helt vilse!", \
                    "Pfft, knappast.", \
                    "Men du är ju hopplös!", \
                    "Skärp dig!"]

help_string = """Möjliga kommandon:
------------------
'hjälp': Skicka detta hjälpmeddelande.
'vem':   Talar om vem som är gazonk.
'visa':  Listar givna ledtrådar.
'nästa': Talar om hur långt det är kvar till nästa ledtråd.\n
Om du är gazonk:
----------------
'lösenord':                     Visar lösenord om omgången är startad.
'lösenord <nytt lösenord>':     Byter lösenord då omgång ej är startad.
'ledtråd':                      Visar alla ledtrådar.
'ledtråd <en ledtråd>':         Lägger in en ny ledtråd.
'byt ledtråd <nr> <en ledtråd>: Byter ut en ledtråd mot en annan.\n
Om du inte är gazonk:
---------------------
'gissa <gissning>:              Gissa på lösenordet.
'<gissning>:                    Samma som ovan.
'ny gazonk':                    Bli gazonk, om ingen är gazonk redan."""

class Gazonk:
    re_auto_reply = re.compile("^Auto-reply:", re.IGNORECASE)
    re_ny_gazonk = re.compile("^ny gazonk", re.IGNORECASE)
    re_losenord_a = re.compile("^lösenord", re.IGNORECASE)
    re_losenord_b = re.compile("^[Ll][Öö][Ss][Ee][Nn][Oo][Rr][Dd] *([" + GAZ_PW_CHARS + \
                               "]{1," + str(GAZ_PW_LENGTH) + "}) *$")
    re_gissning = re.compile("^[" + GAZ_PW_CHARS + "]{1," + str(GAZ_PW_LENGTH) + "}$")
    re_ledtrad = re.compile("^ledtråd *(.*) *$", re.IGNORECASE)
    re_byt_ledtrad = re.compile("^byt ledtråd *([0-9]+) *(.*) *$", re.IGNORECASE)
    re_gissa = re.compile("^gissa *(.*) *$")
    re_vem = re.compile("^vem", re.IGNORECASE)
    re_visa = re.compile("^visa", re.IGNORECASE)
    re_nasta = re.compile("^nästa", re.IGNORECASE)
    re_hjalp = re.compile("^hjälp", re.IGNORECASE)

    def __init__(self):
        self.monthly = MonthlyStats()
        self.current_guesses = GuessDB()
        self.reset()
        self.monthly.reset()

    def reset(self):
        self.person_no = -1
        self.password = "";
        self.clues = []
        self.current_clue = -1
        self.time_last_action = -1
        self.warnings_sent = 0
        self.last_text_no = -1
        self.current_guesses.reset()
        self.per_clue_guesses = []

    def set_last_action(self):
        self.time_last_action = time.time()

    def create_guess_list_string(self, max_nr = MAX_ENTRIES_GUESS_LIST):
        message = ""
        i = 0
        for gdb in self.per_clue_guesses:
            i += 1
            message += "Gissningar för ledtråd %d:\n" % i
            message += "----------------------------\n"
            message += "%d. %s" % (i, self.clues[i-1])
            message += "\n----------------------------\n"
            message += gdb.create_string(MAX_ENTRIES_GUESS_LIST)
            message += "\n"

        message += "Alla gissningar:\n"
        message += "----------------------------\n"
        message += self.current_guesses.create_string(MAX_ENTRIES_GUESS_LIST, "Totalt")
        return message

    def create_clue_string(self, disp_all):
        clues = self.clues
        if disp_all == 0:
            if self.current_clue == -1:
                return "Inga ledtrådar att visa\n"
            clues = clues[:(self.current_clue+1)]
        elif disp_all == 2:
            if self.current_clue == -1:
                return "Inga ledtrådar att visa\n"
            clues = clues[(self.current_clue+1):]

        if len(clues) == 0:
            return "Inga ledtrådar att visa\n"

        clue_string = ""
        i = 0
        if disp_all == 2:
            i = self.current_clue+1
        for c in clues:
            i += 1
            clue_string += str(i) + ". " + c + "\n"
        return clue_string

    def send_end_of_round_message(self, subject, message):
        message += "\n\nLösenordet var '%s'.\n\n" % self.password
        message += "Givna ledtrådar:\n"
        message += self.create_clue_string(0)
        message += "\nIcke givna ledtrådar:\n"
        message += self.create_clue_string(2) + "\n"
        message += self.create_guess_list_string(MAX_ENTRIES_GUESS_LIST)
        self.send_letter(subject, message, GAZONK_CONF, 0, 0)

    def send_next_clue_letter(self, dont_increase = 0):
        new = 0
        if dont_increase == 0:
            self.current_clue += 1
            self.monthly.new_given_clue()
            self.per_clue_guesses.append( GuessDB() )
            if self.current_clue == 0:
                new = 1

        gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
        mess_subject = "<Person %d: %s> gazonkar" % (self.person_no, gaz_name)
        mess_text = self.create_clue_string(0)
        self.send_letter(mess_subject, mess_text, GAZONK_CONF, new, 0)

    def send_clue_message(self, recipient, disp_all):
        send_string = "Ledtrådar:\n\n"
        send_string += self.create_clue_string(disp_all)

        send_message(send_string, recipient)

    def send_letter(self, subject, message, recipient, new, person):
        recipient_name = kom.ReqGetUconfStat(conn, recipient).response().name
        log("%s: Brev till %s:" % (get_date_and_time(), recipient_name))
        log(indent(message, 2) + "\n")

        misc_info = kom.CookedMiscInfo()
        rec = kom.MIRecipient(kom.MIR_TO, recipient)
        misc_info.recipient_list.append(rec)

        if new == 0 and person == 0 and self.last_text_no > 0:
            try:
                ts = conn.textstats[self.last_text_no]
                mic = kom.MICommentTo(kom.MIC_COMMENT, self.last_text_no)
                misc_info.comment_to_list.append(mic)
            except:
                log("Old text number %d not found" % self.last_text_no)

        send_text = subject + "\n" + message
        text_no = kom.ReqCreateText(conn, send_text, misc_info, []).response()
        if person == 0:
            self.last_text_no = text_no

    def check_monthly(self):
        self.monthly.check(self)

    def check_clues(self):
        log("Checking if we should send out clues or warnings.")

        # Skall vi börja en ny omgång?
        if len(self.password) > 0 and \
           len(self.clues) > 0 and \
           self.current_clue == -1:
            self.send_next_clue_letter()
            self.set_last_action()
            self.warnings_sent = 0
            self.monthly.new_round()
            return

        current_time = time.time()
        # Skall vi skicka ut en ny ledtråd?
        if self.current_clue > -1 and \
           len(self.clues) > self.current_clue + 1 and \
           current_time - self.time_last_action > GAZONK_CLUE_TIME:
            self.send_next_clue_letter()
            self.set_last_action()
            self.warnings_sent = 0
            return

        # Dags att skicka ut påminnelse tro?
        if self.person_no > 0 and \
           ((len(self.password) == 0 and len(self.clues) == 0) or \
            len(self.clues) <= self.current_clue + 1) and \
           current_time - self.time_last_action > \
           GAZONK_REMEMBER_TIME * (self.warnings_sent + 1):
            self.warnings_sent += 1

            # Har vi skickat tillräckligt med varningar nu?
            if self.warnings_sent > GAZ_MAX_WARNINGS:
                my_name = kom.ReqGetUconfStat(conn, KOMPERSON).response().name
                gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
                self.send_letter("Du är inte längre gazonk!",
                                 "Du har inte lyssnat på varningarna och blir därmed \n" + \
                                 "fråntagen din gazonktitel!",
                                 self.person_no, 1, 1)
                subject = "<Person %d: %s> ej längre gazonk!" % (self.person_no, gaz_name)
                message = "Vem som helst kan nu bli gazonk. Skicka bara 'ny gazonk'" + \
                          "\ni ett meddelande till <Person %d: %s>" % (KOMPERSON, my_name)
                if len(self.password) > 0 and len(self.clues) > 0:
                    self.send_end_of_round_message(subject, message)
                else:
                    self.send_letter(subject, message, GAZONK_CONF, 0, 0)
                self.reset()
                return

            # Skicka varningen
            message = "Det finns inte tillräckligt med ledtrådar i ledtrådskön."
            future_warnings = GAZ_MAX_WARNINGS - self.warnings_sent
            if self.warnings_sent >= 2:
                message += "\n\nOm ledtrådskön ej fyllts på efter %d fler varningar \n" % \
                           future_warnings
                message += "kommer din gazonk-titel att fråntas dig!"
            self.send_letter("Detta är en påminnelse om att du är gazonk!",
                             message, self.person_no, 1, 1)
            return

    def parse_message(self, msg, c):
        #Om det inte är till gazonk personligen, skall vi inte svara.
        if msg.recipient != KOMPERSON:
            return

        sender_name = kom.ReqGetUconfStat(conn, msg.sender).response().name
        log("%s: Meddelande (%d) från %s:" % (get_date_and_time(), msg.recipient, sender_name))
        log(indent(msg.message, 2) + "\n")

        # Svara ej på automatsvar.
        m = Gazonk.re_auto_reply.search(msg.message)
        if m:
            return

        # Behöver man hjälp?
        m = Gazonk.re_hjalp.search(msg.message)
        if m:
            send_message(help_string, msg.sender)
            return

        # Saker som endast kan göras om ingen gazonk finns:
        if self.person_no == -1:
            # Är detta en request för ny gazonk?
            m = Gazonk.re_ny_gazonk.search(msg.message)
            if m:
                self.reset()
                self.person_no = msg.sender
                self.set_last_action()
                send_message("Du är nu ny gazonk!", msg.sender)
                return

        # Saker som endast nuvarande gazonk får göra:
        if self.person_no == msg.sender:
            # Skall vi sätta ett nytt lösenord
            ma = Gazonk.re_losenord_a.search(msg.message)
            mb = Gazonk.re_losenord_b.match(msg.message)
            # Vi får enbart sätta lösenordet om omgången ej är startad än.
            # Skicka tillbaka lösenordet istället.
            if ma and self.current_clue > -1:
                send_message("Har du blivit senil? Nuvarande lösenord är '%s'." % \
                             self.password, \
                             msg.sender)
                return
            elif ma and mb:
                self.password = mb.group(1)
                self.clues = []
                self.current_clue = -1
                self.time_last_action = -1
                self.warnings_sent = 0
                self.last_text_no = 0
                self.set_last_action()
                send_message("Nytt lösenord är '%s'." % self.password, msg.sender)
                return
            elif ma:
                send_message("Ditt lösenord godkändes ej.\n\n" + \
                             "Ett lösenord skall enbart innehålla bokstäverna\n" + \
                             "a-z, å, ä, ö, samt vara mellan 1 och %d bokstäver långt." % \
                             GAZ_PW_LENGTH, \
                             msg.sender)
                return

            # Skall vi lägga till en ny ledtråd?
            m = Gazonk.re_ledtrad.match(msg.message)
            if m and len(self.password) == 0:
                send_message("Skriv in lösenord innan du skriver in ledtrådar.", msg.sender)
                return
            elif m:
                clue = m.group(1)
                if len(clue) != 0:
                    self.clues.append(m.group(1))
                    self.monthly.new_clue()
                self.send_clue_message(msg.sender, 1)
                return

            # Skall byta ut en ledtråd?
            m = Gazonk.re_byt_ledtrad.match(msg.message)
            if m and len(self.password) == 0:
                send_message("Skriv in lösenord innan du skriver in ledtrådar.", msg.sender)
                return
            elif m:
                nr = int(m.group(1))
                clue = m.group(2)
                if nr > len(self.clues):
                    send_message("Ledtrådsnumret finns inte.", msg.sender)
                    return
                elif nr > 0:
                    self.clues[nr-1] = clue
                    send_message("Ledtråd %d byttes ut till: %s" % (nr, clue), msg.sender)
                    if nr <= self.current_clue + 1:
                        self.send_next_clue_letter(1)
                    return

        # Saker som alla får göra:

        # Vem är gazonk?
        m = Gazonk.re_vem.search(msg.message)
        if m:
            if self.person_no > 0:
                gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
                send_message("<Person %d: %s> är gazonk!" % (self.person_no, gaz_name), \
                             msg.sender)
            else:
                send_message("Ingen person är gazonk just nu!", msg.sender)
            return

        # Visa nuvarande ledtrådar
        m = Gazonk.re_visa.search(msg.message)
        if m:
            if self.current_clue == -1:
                send_message("Ingen gazonk-omgång pågår just nu.", msg.sender)
            else:
                self.send_clue_message(msg.sender, 0)
            return

        # Visa när nästa ledtråd kommer
        m = Gazonk.re_nasta.search(msg.message)
        if m:
            current_time = time.time()
            if self.current_clue == -1:
                send_message("Ingen gazonk-omgång pågår just nu.", msg.sender)
                return
            elif current_time - self.time_last_action > GAZONK_CLUE_TIME:
                send_message("Nästa ledtråd borde redan ha sänts, tjata på gazonk!", msg.sender)
                return
            else:
                next_clue_time = self.time_last_action + GAZONK_CLUE_TIME - current_time
                message = "Det är %d timmar och %d minuter kvar till nästa ledtråd" % \
                          (int(next_clue_time/3600), int(next_clue_time/60))
                send_message(message, msg.sender)
                return

        # Saker som alla utom gazonk får göra:
        if self.person_no != msg.sender:
            if self.current_clue == -1:
                send_message("Ingen gazonk-omgång pågår just nu.", msg.sender)
                return
            # Har vi gissat rätt lösenord?
            m = Gazonk.re_gissa.match(msg.message)
            sm = msg.message.strip()

            guess = sm
            if m:
                guess = m.group(1)

            gm = Gazonk.re_gissning.search(guess)
            if not gm:
                send_message("Din gissning godkändes ej.\n\n" + \
                             "Ett lösenord innehåller enbart bokstäverna\n" + \
                             "a-z, å, ä, ö, samt är mellan 1 och %d bokstäver långt." % \
                             GAZ_PW_LENGTH, \
                             msg.sender)
                return

            # Lägg till gissningen i lite gissningsdatabaser.
            self.current_guesses.add(guess)
            self.per_clue_guesses[self.current_clue].add(guess)

            if guess == self.password:
                self.monthly.add_guess(guess, msg.sender, 1)
                send_message("Grattis, Du gissade rätt!\nDu är nu ny gazonk!", msg.sender)
                gaz_name = kom.ReqGetUconfStat(conn, self.person_no).response().name
                new_gaz_name = kom.ReqGetUconfStat(conn, msg.sender).response().name
                mess_subject = "<Person %d: %s> gazonkar" % (self.person_no, gaz_name)
                mess_text = "<Person %d: %s> klarade lösenordet och är ny gazonk!" % \
                            (msg.sender, new_gaz_name)
                self.send_end_of_round_message(mess_subject, mess_text)
                self.reset()
                self.person_no = msg.sender
                self.set_last_action()
                return
            else:
                self.monthly.add_guess(guess, msg.sender, 0)
                send_message(random.choice(wrong_guess_list), msg.sender)
                return

        # Detta kommando var inte begripligt
        send_message("Jag begriper inte vad du vill göra!", msg.sender)
        return

class MonthlyStats:
    def __init__(self):
        self.guesses = GuessDB()
        self.reset()

    def reset(self):
        self.guesses.reset()
        self.people = {}
        self.round_count = 0
        self.given_clue_count = 0
        self.clue_count = 0
        self.disp_stat = GAZ_DISPLAY_STATISTICS
        self.now = self.get_now_num()

    def get_now_num(self):
        if self.disp_stat == 0:
            return -1
        tmptime = time.localtime(time.time())
        tmpconv = {0: -1, 1: 3, 2: 2, 3: 6, 4: 1, 5: 0}
        return tmptime[tmpconv[self.disp_stat]]

    def new_round(self):
        self.round_count += 1

    def new_given_clue(self):
        self.given_clue_count += 1

    def new_clue(self):
        self.clue_count += 1

    def add_guess(self, guess, person, win = 0):
        self.guesses.add(guess)
        if not self.people.has_key(person):
            self.people[person] = MonthlyPersonStats()
        self.people[person].add_guess(guess, person, win)

    def check(self, g):
        if self.disp_stat == 0:
            return
        current = self.get_now_num()
        if current != self.now:
            # It is a new hour/day/week/month/year, so display stats.
            mstrings = { 1: ("Den", "timme", "timmen"), \
                         2: ("Den", "dag", "dagen"), \
                         3: ("Den", "vecka", "veckan"), \
                         4: ("Den", "månad", "månaden"), \
                         5: ("Det", "år", "året") }
            (dd, mob, mbest) = mstrings[self.disp_stat]

            subject = "Statistik för den senaste %s." % mbest
            message = "%s senaste %s har %d gazonkningar påbörjats och\n" % \
                      (dd, mbest, self.round_count)
            message += "det har gjorts totalt %d gissningar på sammanlagt %d givna\n" % \
                       (self.guesses.count, self.given_clue_count)
            message += "ledtrådar. Totalt %d ledtrådar angavs.\n\n" % self.clue_count

            message += """Gissn  = antal gissningar
Korr   = antal korrekta gissningar
k/g    = andel korrekta gissningar (procent)
person = för denna person
fo     = flest gissningar på dessa ord

Statistik över personer som röstat:
-----------------------------------
 Gissn Korr   k/g  person
"""

            plist_tmp = zip(self.people.values(), self.people.keys())
            plist = [(value.guesses.count, key, value) for (value,key) in plist_tmp]
            plist.sort()
            plist.reverse()

            for (guesscount, person, pstats) in plist:
                pname = kom.ReqGetUconfStat(conn, person).response().name
                kpg = "%3.1f%%" % (float(pstats.win_count)/float(guesscount)*100.0)
                row = string.rjust(str(guesscount),6) + " " + \
                      string.rjust(str(pstats.win_count),4) + " " + \
                      string.rjust(kpg, 6) + " " + \
                      "<Person %d: %s>" % (person, pname)
                row = row[:72]

                glist = zip(pstats.guesses.db.values(), pstats.guesses.db.keys())
                glist.sort()
                glist.reverse()
                srow = "       fo"
                c = ":"
                for (amount, guess) in glist[:3]:
                    srow += c + " %d %s" % (amount, guess)
                    if c == ":":
                        c = ","
                message += row + "\n" + srow + "\n"

            message += "\nAlla gissningar:\n"
            message += "----------------------------\n"
            message += self.guesses.create_string(MAX_ENTRIES_GUESS_LIST, "Totalt")

            g.send_letter(subject, message, GAZONK_CONF, 1, 1)

            # Now reset the stats for next period.
            self.reset()

class MonthlyPersonStats:
    def __init__(self):
        self.guesses = GuessDB()
        self.win_count = 0

    def reset(self):
        self.guesses.reset()
        self.win_count = 0

    def add_guess(self, guess, person, win = 0):
        self.guesses.add(guess)
        if win == 1:
            self.win_count += 1

# Liten klass för att hålla reda på ord.
class GuessDB:
    def __init__(self):
        self.db = {}
        self.count = 0

    def reset(self):
        self.db = {}
        self.count = 0

    def add(self, guess):
        self.count += 1
        if not self.db.has_key(guess):
            self.db[guess] = 1
        else:
            self.db[guess] += 1

    def create_string(self, max_nr = MAX_ENTRIES_GUESS_LIST, total_word = "Sammanlagt"):
        glist = zip(self.db.values(), self.db.keys())
        glist.sort()
        glist.reverse()

        guess_string = ""
        for (amount, guess) in glist[:max_nr]:
            guess_string += string.ljust(guess, min(GAZ_PW_LENGTH + 9, 60)) + \
                            " " + string.rjust(str(amount), 5) + "\n"
        if self.count == 0:
            guess_string += "Inga gissningar.\n" 
        elif self.count == 1:
            guess_string += "----------------------------\n"
            guess_string += "%s 1 gissning.\n" % total_word
        else:
            guess_string += "----------------------------\n"
            guess_string += "%s %d gissningar.\n" % (total_word, self.count)
        return guess_string

# Loggning
def log(txt):
    if LOG == 1:
        if txt[-1:] <> "\n":
            txt = txt + "\n"
        logfile.write(txt)
        logfile.flush()

def get_date_and_time():
    return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime(time.time()))

# Indentering
def indent(txt, spaces):
    lines = string.split(txt, "\n")
    lines = map(lambda line, prefix=" "*spaces: prefix + line, lines)
    return string.join(lines, "\n")

def send_message(message, recipient):
    recipient_name = kom.ReqGetUconfStat(conn, recipient).response().name
    log("%s: Meddelande till %s:" % (get_date_and_time(), recipient_name))
    log(indent(message, 2) + "\n")

    try:
        kom.ReqSendMessage(conn, recipient, message).response()
        kom.ReqUserActive(conn).response()
    except:
        log("Misslyckades med att skicka meddelande.")

#
# Huvudkod
#

random.seed()

# Öppna en logfil, kan vara bra att ha :-)
logfile = open(LOGFILE, "a")
log("Starting")

# Skapa en gazonk-information
if os.path.exists(DUMPFILE):
    gaz = cPickle.load(open(DUMPFILE))
else:
    gaz = Gazonk();

# Koppla upp sig, logga in och annat kul
log("Kopplar upp")
conn = kom.CachedConnection(KOMSERVER, port = KOMPORT)
log("Loggar in")
kom.ReqLogin(conn, KOMPERSON, KOMPASSWORD, INVISIBLE).response()
kom.ReqSetClientVersion(conn, CLIENTNAME, VERSION)
log("Gazonk!")

# Hantera meddelanden

conn.add_async_handler(kom.ASYNC_SEND_MESSAGE, gaz.parse_message)
kom.ReqAcceptAsync(conn, [kom.ASYNC_SEND_MESSAGE]).response()

while 1:
    select.select([conn.socket], [], [], MAX_SLEEP_TIME)
    conn.parse_present_data()
    gaz.check_clues()
    gaz.check_monthly()
    cPickle.dump(gaz, open(DUMPFILE, 'w'), DUMPBIN)
