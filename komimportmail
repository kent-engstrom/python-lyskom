#!/usr/bin/python-1.5.2
# LysKOM Protocol A version 10 client interface for Python
# $Id: komimportmail,v 1.6 1999/07/23 13:17:58 kent Exp $
# (C) 1999 Kent Engström. Released under GPL.

# Note: Python 1.5.2 is needed because of mimereader, which needs
# to call multifile.MultiFile with seekable = 0.

import sys
import string
import time
import mimereader
import rfc822
import rfc1522
import lockingshelve
import kom

# Configuration

KOMSERVER = "localhost"
KOMPORT = 4894
KOMPERSON = 21
KOMPASSSWORD = "eppelpost"
LOGFILE = "/home/kent/lyskom/python-lyskom/maillog"
ID_DB_FILE = "/home/kent/lyskom/python-lyskom/message-id"
APPENDIX_TEXT_NONAME = "Bilaga till: "
APPENDIX_TEXT = "Bilaga (%s) till: "

# Get revision number from RCS/CVS
vc_revision = "$Revision: 1.6 $"
revision = vc_revision[11:-2]

# Error reporting
def fatal(str):
    sys.stderr.write("ERROR: " + str + "\n")
    sys.exit(1)

# Send a text (subject, body, Misc-Info and Aux-Items) to KOM.
# Destructively prune comment-to/footnote-to Misc-Info items
# if they seem to cause problems.
# Return text_no or throw exception.
def send_to_kom(subject, body, misc_info, aux_items):
    attempting_to_send = 1
    while attempting_to_send:
        try:
            text_no = kom.ReqCreateText(c,
                                        subject + "\n" + body,
                                        misc_info, aux_items).response()
            attempting_to_send = 0
        except kom.NoSuchText, error_status:
            # We assume this is because of a bad Comment-To link
            # (perhaps the text we are trying to comment has been
            # deleted). Remove the offending Misc-Info entry and
            # try again, if possible.
            attempting_to_send = 0
            try:
                bad_text_no = string.atoi(str(error_status))
                for i in range(0,len(misc_info.comment_to_list)):
                    if misc_info.comment_to_list[i].text_no == bad_text_no:
                        del misc_info.comment_to_list[i]
                        attempting_to_send = 1
                        break
            except:
                # If we fail to remove the offending Misc-Info item,
                # we raise an exception
                raise kom.NoSuchText, bad_text_no # hope it was set

    return text_no

# Handle email (decode and send to KOM) 
# Note: parent = None means that this is the top node (first message part)
#       parent = text_no means that this is a subnode (subsequent part)

def create_article(envelope_sender,
                   envelope_recipients,
                   mail_headers,
                   part_headers,
                   body,
                   parent = None):

    # Open threading database of ID:s
    try:
        id_db = lockingshelve.LockingShelve(ID_DB_FILE)
    except:
        fatal("Cannot access ID database")

    # Fix Misc-Info and Aux Item list for later user
    misc_info = kom.CookedMiscInfo()
    aux_items = []

    # Add recipients
    no_of_valid_recipients = 0
    for envelope_recipient in envelope_recipients:
        # Try to get recipient conference (or person = letterbox) from
        # the envelope recipient. We expect a single integer, the
        # LysKOM conf_no. Perhaps we will add other address forms later.

        try:
            conf_no = string.atoi(envelope_recipient)
        except:
            continue

        try:
                conf_stat = c.conferences[conf_no]
        except:
            continue

        # Add recipient to Misc-Info
        mir = kom.MIRecipient(type = kom.MIR_TO, recpt = conf_no)
        misc_info.recipient_list.append(mir)
        no_of_valid_recipients = no_of_valid_recipients + 1

    if no_of_valid_recipients == 0:
        fatal("No valid recipients found")


    # If the In-Reply-To header is present, we attempt threading.
    # According to the DRUMS document, the In-Reply-To-field should
    # never contain multiple ID:s, and there should never be more
    # than one header line of this type. Is that true? If not, we
    # will have to extend this code to handle multiple values.
    # We only thread the first MIME part.

    if parent is None and mail_headers.has_key("In-Reply-To"):
        in_reply_to = mail_headers["In-Reply-To"]
        aux_items.append(kom.AuxItem(kom.AI_MX_IN_REPLY_TO,
                                     in_reply_to))
        try:
            (text_no, created) = id_db[in_reply_to]
            mic = kom.MICommentTo(kom.MIC_COMMENT, text_no)
            misc_info.comment_to_list.append(mic)
            log("Threading: comment to %s (text %d)\n" % \
                (in_reply_to, text_no))
        except:
            log("Threading: cannot find %s\n" % (in_reply_to))
            pass

    # If this is not the first MIME part, make it a comment
    # to the first part. Record the link in an aux-item too,
    # so a client can see that this belongs to the same 
    # email.
    
    if parent is not None:
        mic = kom.MICommentTo(kom.MIC_COMMENT, parent)
        misc_info.comment_to_list.append(mic)
        aux_items.append(kom.AuxItem(kom.AI_MX_MIME_BELONGS_TO, str(parent)))
        
    # Creating software (always present)
    aux_items.append(kom.AuxItem(kom.AI_CREATING_SOFTWARE,
                                 "komimportmail %s" % revision))

    
    # Mail headers (only for first MIME part)
    if parent is None:

        # Envelope sender
        aux_items.append(kom.AuxItem(kom.AI_MX_ENVELOPE_SENDER,
                                     envelope_sender))

        # Single header fields
        for (header_name, aux_item_type) in [
            ("Message-ID", kom.AI_MX_MESSAGE_ID),
            ]:
    
            if mail_headers.has_key(header_name):
                aux_items.append(kom.AuxItem(aux_item_type,
                                             rfc1522.decode(mail_headers[header_name])))
    
        # Adress header fields. The format is one of:
        # - email address (e.g. "kent@lysator.liu.se")
        # - fullname <email> (e.g. "Kent Engström <kent@lysator.liu.se>")
        # N.B.: we do not fill in the mx-author aux-item.
        for (header_name, aux_item_type) in [
            ("From", kom.AI_MX_FROM),
            ("To", kom.AI_MX_TO),
            ("Cc", kom.AI_MX_CC),
            ("Reply-To", kom.AI_MX_REPLY_TO),
            ]:
    
            for (name_part, email_part) in mail_headers.getaddrlist(header_name):
                name_part = rfc1522.decode(name_part)
                if name_part:
                    email = "%s <%s>" % (name_part, email_part)
                else:
                    email = email_part
                aux_items.append(kom.AuxItem(aux_item_type, email))
                                             
    
        # Date
        if mail_headers.has_key("Date"):
            parsed_date = rfc822.parsedate_tz(mail_headers["Date"])
            if parsed_date is not None:
                tz_mins = parsed_date[9] / 60
                if tz_mins == 0:
                    tz = "+0000"
                elif tz_mins > 0:
                    tz = "+%02d%02d" % (tz_mins/60, tz_mins % 60)
                else:
                    tz_mins = -tz_mins
                    tz = "-%02d%02d" % (tz_mins/60, tz_mins % 60)
                    
                date = "%04d-%02d-%02d %02d:%02d:%02d %s" % \
                       (parsed_date[0], parsed_date[1], parsed_date[2],
                        parsed_date[3], parsed_date[4], parsed_date[5],
                        tz)
                aux_items.append(kom.AuxItem(kom.AI_MX_DATE, date))
    
        # The complete set of mail headers (no decoding of these)
        aux_items.append(kom.AuxItem(kom.AI_MX_MISC,
                                     string.join(mail_headers.headers, "")))

    # MIME Content type
    mime_type = part_headers.gettype()
    aux_items.append(kom.AuxItem(kom.AI_MX_MIME_CONTENT_TYPE,
                                 mime_type))

    # Old standard for KOM content type (a line first in the body)
    kom_type = ""
    if mime_type == "text/html":
        kom_type = "html:\n"
    body = kom_type + body

    # MIME filename (Name parameter of Content-Type header)
    filename = part_headers.getparam("name")
    if filename is not None:
        aux_items.append(kom.AuxItem(kom.AI_MX_MIME_FILE_NAME,
                                     filename))

    # The complete set of MIME part headers (no decoding of these)
    # FIXME: If the imported mail is just one single discrete part, this
    # is identical to the mail headers in MX_MISC.
    aux_items.append(kom.AuxItem(kom.AI_MX_MIME_MISC,
                                 string.join(part_headers.headers, "")))

    # Subject
    if mail_headers.has_key("Subject"):
        subject = rfc1522.decode(mail_headers["Subject"])
    else:
        subject = ""

    # If this is not the first part, add text to subject about appendix
    if parent is not None:
        if filename is None:  
            subject = APPENDIX_TEXT_NONAME + subject
        else:
            subject = APPENDIX_TEXT % filename + subject
      
    # Send
    try:
        text_no = send_to_kom(subject, body, misc_info, aux_items)
    except:
        fatal("Failed to send text (%s)" % sys.exc_info()[0])
                          
    # Register mapping Message-ID -> text number (if threading)
    
    if parent is None and mail_headers.has_key("Message-ID"):
        try:
            id_db[mail_headers["Message-ID"]] = (text_no, int(time.time()))
        except:
            pass

    return text_no
                
# MAIN

# Log file
log_file = open(LOGFILE, "a")
log = log_file.write

# Arguments

if len(sys.argv) < 3:
    fatal("Wrong number of arguments")
envelope_sender = sys.argv[1]
envelope_recipients = sys.argv[2:]

# Connect and log in

try:
    c = kom.CachedConnection(KOMSERVER, KOMPORT)
    try:
        kom.ReqLogin(c, KOMPERSON, KOMPASSSWORD, invisible=1).response()
    except:
        fatal("Failed to login to LysKOM server")
except:
    fatal("Failed to connect to LysKOM server")

# Read MIME mail. MIME multipart handling is really simple:
# We get all discrete parts in a linear list, and let the first
# part be the main article. All remaining parts will become
# comments to this article, regardless of the original
# hierarchical structure in the MIME message.

mail = mimereader.Message(sys.stdin)
parts = mail.linear_list_of_discrete_parts()


# Handle the first (and maybe only part)
log("Handling article %s -> %s\n" % (envelope_sender, envelope_recipients))
text_no = create_article(envelope_sender, envelope_recipients,
                         mail.headers, parts[0].headers, parts[0].data,
                         parent = None)

# Handle the rest of the parts as comments to the first part
for part in parts[1:]:
    # Only text/* and message/* is allowed now.
    if part.maintype in ["text","message"]:
        sub_text_no = create_article(envelope_sender, envelope_recipients,
                                     mail.headers, part.headers, part.data,
                                     parent = text_no)

# Exit successfully
sys.exit(0)
