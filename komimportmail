#!/usr/bin/python-1.5.2
# LysKOM Protocol A version 10 client interface for Python
# $Id: komimportmail,v 1.9 1999/07/26 12:53:32 kent Exp $
# (C) 1999 Kent Engström. Released under GPL.

# Note: Python 1.5.2 is needed because of mimereader, which needs
# to call multifile.MultiFile with seekable = 0.

import sys
import string
import time
import mimereader
import rfc822
import rfc1522
import lockingshelve
import kom
import os

# -- CONFIGURATION BEGINS HERE ---

# How to connect to the server
KOMSERVER = "localhost"
KOMPORT = 4894
KOMPERSON = 21
KOMPASSSWORD = "eppelpost"

# File to log some information into
LOG_FILE = "/home/kent/lyskom/python-lyskom/maillog"

# File for message-id -> text-no database
# Note: the actual filename depends on what database shelve.py chooses.
ID_DB_FILE = "/home/kent/lyskom/python-lyskom/message-id"

# Text to prepend to subject header of appendices
APPENDIX_SUBJECT_PREFIX_NONAME = "Bilaga till: "
APPENDIX_SUBJECT_PREFIX = "Bilaga (%s) till: "

# Use comments or footnotes when linking appendices to the main article?
APPENDIX_COMMENT_TYPE = kom.MIC_COMMENT #or kom.MIC_FOOTNOTE

# -- CONFIGURATION ENDS HERE ---

# Get revision number from RCS/CVS
vc_revision = "$Revision: 1.9 $"
revision = vc_revision[11:-2]

# Error reporting to stderr and logfile
def fatal(str):
    line = "FATAL: " + str
    sys.stderr.write(line + "\n")
    log(line)
    sys.exit(1)

# Logging

log_file = None
log_pid = None
def log(line):
    global log_file
    global log_pid
    
    if log_file is None:
        log_file = open(LOG_FILE, "a")

    if log_pid is None:
        log_pid = os.getpid()
        
    log_file.write("%d: %s\n" % (log_pid, line))

# Create an article or add recipients to an existing one
def create_article_or_add_recipients(mail,
                                     envelope_sender,
                                     envelope_recipients):
    # Get Message-ID
    try:
        message_id = mail.headers["Message-ID"]
    except:
        fatal("No message ID in mail")

    log("Handling mail with Message-ID: %s" % message_id)

    # Lookup Message-ID -> Text-No (fails if this is a new mail)
    try:
        (existing_text_no, added_time_t) = message_id_db[message_id]
        log("This is existing article %d" % existing_text_no)
    except KeyError:
        log("This mail is new")
        existing_text_no = None

    # Map recipient names to conference numbers
    recipient_list = name_list_to_conf_no_list(envelope_recipients)
    if len(recipient_list) == 0:
        fatal("No valid recipients found")

    # Choose function
    if existing_text_no is None:
        # We should create a new article based on this mail
        create_article(mail, envelope_sender, recipient_list,
                       message_id)
    else:
        # We should add new recipients to this article
        add_recipients(mail, envelope_sender, recipient_list,
                       message_id, existing_text_no)


# Create a new article based on this mail
def create_article(mail, envelope_sender, envelope_recipients,
                   message_id):

    # Threading. If the In-Reply-To header is present, we attempt
    # threading.  According to my interpretation of the mail
    # standards, the In-Reply-To-field should never contain multiple
    # ID:s, and there should never be more than one header line of
    # this type. Is that true? If not, we will have to extend this
    # code to handle multiple values.

    in_reply_to_text_no = None
    if mail.headers.has_key("In-Reply-To"):
        in_reply_to = mail.headers["In-Reply-To"]
        try:
            (in_reply_to_text_no, created) = message_id_db[in_reply_to]
            log("In reply to %s (article %d)" % \
                (in_reply_to, in_reply_to_text_no))
        except:
            log("In reply to %s (which cannot be found in KOM)" % \
                (in_reply_to))

    # MIME multipart handling.  We choose not to preserve the exact
    # hierachical structure of the MIME message itself, as that would
    # lead to a situation where the articles corresponding to the
    # "inner nodes", e.g. multipart/mixed, would be empty and serve
    # only as placeholders for comments. Instead, we do something
    # really simple: We get all discrete parts in a linear list, and
    # let the first part be the main article. All remaining parts will
    # become comments to this article, regardless of the original
    # hierarchical structure in the MIME message.

    parts = mail.linear_list_of_discrete_parts()
    log("Number of MIME parts: %d" % len(parts))
    
    # Handle the first (perhaps only) part
    text_no = create_article_part(mail,
                                  envelope_sender,
                                  envelope_recipients,
                                  parts[0],
                                  in_reply_to_text_no,
                                  parent = None)

    # Handle the rest of the parts as comments to the first part
    for part in parts[1:]:
        sub_text_no = create_article_part(mail,
                                          envelope_sender,
                                          envelope_recipients,
                                          part,
                                          in_reply_to_text_no,
                                          parent = text_no)

    # Threading. Register Message-ID -> (Text-No, creation time) mapping.
    try:
        message_id_db[message_id] = (text_no, int(time.time())) 
        log("Message-ID recorded in database.")
    except:
        log("Failed to record Message-ID in database.")
        pass

# Create article part
# The "parent" argument tells us if this is the main article or
# an appendix. A lot of actions below depends on this.
def create_article_part(mail,
                        envelope_sender,
                        recipient_list,
                        part,
                        in_reply_to_text_no = None,
                        parent = None):

    # Prepare Misc-Info and Aux Item list for later user
    misc_info = kom.CookedMiscInfo()
    aux_items = []

    # Add recipients to Misc-Info
    for conf_no in recipient_list:
        mir = kom.MIRecipient(type = kom.MIR_TO, recpt = conf_no)
        misc_info.recipient_list.append(mir)

    # Threading of main article based on In-Reply-To.
    if parent is None and in_reply_to_text_no is not None:
        mic = kom.MICommentTo(kom.MIC_COMMENT, in_reply_to_text_no)
        misc_info.comment_to_list.append(mic)

    # Threading of appendices as comments (or footnotes) to the
    # main article. We mark the appendix with a special aux-item,
    # mx-mime-belongs-to to designate it as a MIME appendix.
    if parent is not None:
        mic = kom.MICommentTo(APPENDIX_COMMENT_TYPE, parent)
        misc_info.comment_to_list.append(mic)
        aux_items.append(kom.AuxItem(kom.AI_MX_MIME_BELONGS_TO, str(parent)))
        
    # Let the world know about this marvelous creating software :-)
    aux_items.append(kom.AuxItem(kom.AI_CREATING_SOFTWARE,
                                 "komimportmail %s" % revision))

    # Handle envelope information (creating aux-items)
    # We only put these aux-items on the main article (not on appendices).

    if parent is None:
        aux_items.append(kom.AuxItem(kom.AI_MX_ENVELOPE_SENDER,
                                     envelope_sender))
        # Currently, the envelope recipients are not stored anywhere.
        # Perhaps that would be useful later on if the recognized
        # adresses becomes more advanced than simple integers.

    # Handle mail headers (creating aux-items)
    # We only put these aux-items on the main article (not on appendices).

    if parent is None:
        # Aux-items for non-address single header fields
        for (header_name, aux_item_type) in [
            ("Message-ID", kom.AI_MX_MESSAGE_ID),
            ("In-Reply-To", kom.AI_MX_IN_REPLY_TO),
            ]:
            if mail.headers.has_key(header_name):
                ai = kom.AuxItem(aux_item_type,
                                 rfc1522.decode(mail.headers[header_name]))
                aux_items.append(ai)

        # Aux-items for adress header fields come in three formats:
        #
        # 1) Complete address including name (mailbox in the
        #    terminology of draft-ietf-drums-msg-fmt-07.txt)
        #    Example: "Joe Q. Public" <john.q.public@example.com>
        #         or  john.q.public@example.com
        #
        # 2) Just the bare email address (called addr-spec)
        #    Example: john.q.public@example.com
        # 
        # 3) Just the name (a display-name in the drums specification):
        #    Example: Joe Q. Public
        # 
        # The rationale for using different formats for different aux-items
        # is that the LysKOM clients should not have to be able to
        # parse addresses in order to use Reply-To adresses, etc.

        for (header_name, aux_item_1, aux_item_2, aux_item_3) in [
            ("From", None, kom.AI_MX_FROM, kom.AI_MX_AUTHOR),
            ("To", kom.AI_MX_TO, None, None),
            ("Cc", kom.AI_MX_CC, None, None),
            ("Reply-To", None, kom.AI_MX_REPLY_TO, None),
            ]:
    
            for (display_name, addr_spec) in \
                mail.headers.getaddrlist(header_name):
                # Remove outer double qoutes and RFC1522 coding if
                # present in the display name.                
                if display_name[0:1] == '"' and display_name[-1:0] == '"':
                    display_name = display_name[1:-1]
                display_name = rfc1522.decode(display_name)

                # Recreate mailbox
                if display_name:
                    mailbox = "%s <%s>" % (display_name, addr_spec)
                else:
                    mailbox = addr_spec

                # Add aux-items of the correct type
                if aux_item_1:
                    aux_items.append(kom.AuxItem(aux_item_1, mailbox))
                if aux_item_2:
                    aux_items.append(kom.AuxItem(aux_item_2, addr_spec))
                if aux_item_3:
                    aux_items.append(kom.AuxItem(aux_item_3, display_name))
    
        # Date
        if mail.headers.has_key("Date"):
            parsed_date = rfc822.parsedate_tz(mail.headers["Date"])
            if parsed_date is not None:
                tz_mins = parsed_date[9] / 60
                if tz_mins == 0:
                    tz = "+0000"
                elif tz_mins > 0:
                    tz = "+%02d%02d" % (tz_mins/60, tz_mins % 60)
                else:
                    tz_mins = -tz_mins
                    tz = "-%02d%02d" % (tz_mins/60, tz_mins % 60)
                    
                date = "%04d-%02d-%02d %02d:%02d:%02d %s" % \
                       (parsed_date[0], parsed_date[1], parsed_date[2],
                        parsed_date[3], parsed_date[4], parsed_date[5],
                        tz)
                aux_items.append(kom.AuxItem(kom.AI_MX_DATE, date))
    
        # The complete set of mail headers (no decoding of these)
        aux_items.append(kom.AuxItem(kom.AI_MX_MISC,
                                     string.join(mail.headers.headers,
                                                 "")))

    # Handle MIME headers (creating aux-items)
    # We put these aux-items on the main article and the appendices

    # MIME Content type
    mime_type = part.headers.gettype()
    aux_items.append(kom.AuxItem(kom.AI_MX_MIME_CONTENT_TYPE,
                                 mime_type))
    log("MIME type of this part: %s" % mime_type)

    # MIME filename (Name parameter of Content-Type header)
    mime_filename = part.headers.getparam("name")
    if mime_filename:
        aux_items.append(kom.AuxItem(kom.AI_MX_MIME_FILE_NAME,
                                     mime_filename))

    # The complete set of MIME part headers (no decoding of these)
    # FIXME: If the imported mail is just one single discrete part, this
    # is identical to the mail headers in MX_MISC.
    aux_items.append(kom.AuxItem(kom.AI_MX_MIME_MISC,
                                 string.join(part.headers.headers, "")))


    # Subject
    if mail.headers.has_key("Subject"):
        subject = rfc1522.decode(mail.headers["Subject"])
    else:
        subject = ""

    # The subject of an appendix is slightly modified 
    if parent is not None:
        if mime_filename:
            subject = APPENDIX_SUBJECT_PREFIX % mime_filename + subject
        else:
            subject = APPENDIX_SUBJECT_PREFIX_NONAME + subject
      
    # Try to create article part
    try:
        text_no = send_to_kom(subject, part.data, misc_info, aux_items)
    except:
        fatal("Failed to create article (error %s)" % sys.exc_info()[0])
                          
    return text_no


# Send a text (subject, body, Misc-Info and Aux-Items) to KOM.
# Destructively prune comment-to/footnote-to Misc-Info items
# if they seem to cause problems.
# Return text_no or throw exception.
def send_to_kom(subject, body, misc_info, aux_items):
    attempting_to_send = 1
    while attempting_to_send:
        try:
            text_no = kom.ReqCreateText(c,
                                        subject + "\n" + body,
                                        misc_info, aux_items).response()
            log("Article %d created" % text_no)
            attempting_to_send = 0
        except kom.NoSuchText, error_status:
            # We assume this is because of a bad Comment-To link
            # (perhaps the text we are trying to comment has been
            # deleted). Remove the offending Misc-Info entry and
            # try again, if possible.
            attempting_to_send = 0
            try:
                bad_text_no = string.atoi(str(error_status))
                log("Article creation failed as commented article %d does not exist" % bad_text_no)
                for i in range(0,len(misc_info.comment_to_list)):
                    if misc_info.comment_to_list[i].text_no == bad_text_no:
                        del misc_info.comment_to_list[i]
                        attempting_to_send = 1
                        log("Retrying with offending misc-item removed")
                        break
            except:
                # If we fail to remove the offending Misc-Info item,
                # we raise an exception
                raise kom.NoSuchText, bad_text_no # hope it was set

    return text_no

# Add more recipients to this article
# We do not add new aux-items, even if some headers may be different
# in this copy (e.g. the "Received:" trace lines).
def add_recipients(mail, envelope_sender, recipient_list,
                   message_id, existing_text_no):

    # Just loop and try to add the recipients, silently
    # ignoring any errors from the server.
    for recipient in recipient_list:
        try:
            kom.ReqAddRecipient(c,
                                existing_text_no,
                                recipient,
                                kom.MIR_TO).response()
            log("Added conference %d as recipient" % recipient)
        except kom.ServerError:
            log("Failed (%s) to add conference %d as recipient" % \
                (sys.exc_info()[0], recipient))

# Convert a list of recipient names to a list of conference numbers
# Note that the recipient names should not contain the @ or the domain
# part of the email address, just the local part.
#
# Allowable recipient name formats (in the order they are checked):
# 
# 1) An integer. The conference/letterbox corresponding to this
#    conf_no is the recipient. Note that an invalid integer results
#    in a miss. No further alternatives are checked.
#
# 2) Any other string. Underscores are converted to spaces and the
#    name looked up using lookup-z-name. If there is exactly one match,
#    that conference/letterbox is choosen as recipient.

def name_list_to_conf_no_list(name_list):
    conf_no_list = []
    for name in name_list:

        # 1) Integer = conf_no
        try:
            conf_no = string.atoi(name)
        except:
            conf_no = None

        if conf_no:
            # We have an integer.
            # Do a simple existence check and add.
            try:
                conf_stat = c.conferences[conf_no]
                conf_no_list.append(conf_no)
                log("Numeric recipient %d seems to be OK" % conf_no)
            except:
                log("Numeric recipient %d ignored (conference not found)" % \
                    conf_no)
            continue # No other formats will be checked

        # 2) Other string = name to look up
        matches = c.lookup_name(string.replace(name, "_", " "),
                                want_pers = 1,
                                want_confs = 1)
        if len(matches) == 0:
            log("Name recipient '%s' gave no match" % name)
        elif len(matches) > 1:
            log("Name recipient '%s' gave %d matches (ambiguous)" % \
                (name, len(matches)))
        else:
            log("Name recipient '%s' matches %d: '%s'" % \
                (name, matches[0][0], matches[0][1]))
            conf_no_list.append(matches[0][0])            

    return conf_no_list
        
# MAIN

# Arguments: envelope-sender [envelope-recipient...]

if len(sys.argv) < 3:
    fatal("Wrong number of arguments")
envelope_sender = sys.argv[1]
envelope_recipients = sys.argv[2:]

# Connect and log in

try:
    c = kom.CachedConnection(KOMSERVER, KOMPORT)
    try:
        kom.ReqLogin(c, KOMPERSON, KOMPASSSWORD, invisible=1).response()
    except:
        fatal("Failed to login to LysKOM server")
except:
    fatal("Failed to connect to LysKOM server")

# Prepare to use the Message-ID database
try:
    message_id_db = lockingshelve.LockingShelve(ID_DB_FILE)
except:
    fatal("Cannot access Message-ID database")

# Read MIME mail
mail = mimereader.Message(sys.stdin)

# Create an article or add recipients to an existing one
create_article_or_add_recipients(mail, envelope_sender, envelope_recipients)

# Exit successfully
sys.exit(0)
